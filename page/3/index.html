<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Page 3 | Contunued Story</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta name="description" content="Like a bird in the sky">
<meta property="og:type" content="website">
<meta property="og:title" content="Contunued Story">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Contunued Story">
<meta property="og:description" content="Like a bird in the sky">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Contunued Story">
<meta name="twitter:description" content="Like a bird in the sky">
  
    <link rel="alternate" href="/atom.xml" title="Contunued Story" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body>


  
  
  <div class="site-header-image">
    <img id="originBg" width="100%" alt="Hike News" src="">
  </div>

  <div id="header-blur" class="site-header-image blur" style="position: absolute; top:0; height: 207px; min-height: 207px; min-width: 100%;">
    <img id="blurBg" width="100%" style="top: 96%" alt="Hike News" src="">
  </div>

  <script>
        var imgUrls = "css/images/pose01.jpg,https://source.unsplash.com/collection/954550/1920x1080,https://source.unsplash.com/collection/954550/1920x1081".split(",");
        var random = Math.floor((Math.random() * imgUrls.length ));
        if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
          document.getElementById("originBg").src=imgUrls[random];
          document.getElementById("blurBg").src=imgUrls[random];
        } else {
          document.getElementById("originBg").src='/' + imgUrls[random];
          document.getElementById("blurBg").src='/' + imgUrls[random];
        }
    </script>




<header id="allheader" class="site-header" role="banner" 
   style="width: 100%; position: absolute; top:0; background: rgba(255,255,255,.8);"  >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="Contunued Story" rel="home"> Contunued Story </a>
            
          </h1>
          
          
            <div class="site-description">Like a bird in the sky</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">Tags</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-Java框架-Spring"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/05/Java框架-Spring/">Java框架-Spring</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/05/Java框架-Spring/" class="article-date">
	  <time datetime="2019-11-05T14:46:40.000Z" itemprop="datePublished">November 5, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Spring/">Spring</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>此篇文章帮助自己 从Spring 的源码角度了解Spring的原理</p>
<hr>
<h2 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h2><p>IOC（Inversion of Control）：控制反转；Spring Core最核心部分；<br>IOC是一种思想。</p>
<h3 id="实现手段：依赖注入（Dependency-Injection）"><a href="#实现手段：依赖注入（Dependency-Injection）" class="headerlink" title="实现手段：依赖注入（Dependency Injection）"></a>实现手段：依赖注入（Dependency Injection）</h3><p>把底层类作为参数传递给上层类，实现上层对下层的“控制”</p>
<p><img src="/2019/11/05/Java框架-Spring/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.jpg" alt></p>
<h4 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h4><ul>
<li>Setter Setter注入</li>
<li>Interface 接口注入</li>
<li>Constructor 构造器注入</li>
<li>Annotation 注解注入</li>
</ul>
<h4 id="依赖倒置原则、IOC、DI、IOC容器的关系"><a href="#依赖倒置原则、IOC、DI、IOC容器的关系" class="headerlink" title="依赖倒置原则、IOC、DI、IOC容器的关系"></a>依赖倒置原则、IOC、DI、IOC容器的关系</h4><p><img src="/2019/11/05/Java框架-Spring/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%E3%80%81IOC%E3%80%81DI%E3%80%81IOC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt></p>
<ol>
<li>依赖倒置原则是一种思想，高层模块不应该依赖底层模块；  </li>
<li>有了依赖倒置原则才有了IOC的思路；  </li>
<li>实现IOC的思路又需要依赖注入的支撑；  </li>
<li>Spring的框架基于IOC提出了容器的概念，对于IOC来说最重要的就是容器了，容器管理着bean的生命周期，控制着bean的依赖注入。</li>
</ol>
<h3 id="IOC容器的优势"><a href="#IOC容器的优势" class="headerlink" title="IOC容器的优势"></a>IOC容器的优势</h3><ul>
<li>避免在各处使用new来创建类，并且可以做到统一维护</li>
<li>创建实例的时候不需要了解其中的细节<br>当使用的时候，IOC容器在内部已经完成对象，调用者只需要调用即可！<br>如图蓝色部分全部是由IOC容器完成！</li>
</ul>
<p><img src="/2019/11/05/Java框架-Spring/ioc%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BC%98%E5%8A%BF.jpg" alt></p>
<p>因为采用了依赖注入在初始化的过程中就不可避免的写大量的new,这里IOC容器就解决了这个问题，这个容器可以自动对代码初始化，你需要维护一个configuration,可以是xml或者可以是一段代码，而不用每次初始化一个行李箱，写一大堆的初始化代码  </p>
<p>IOC容器可以隐藏具体创建实例的细节，上图中蓝色部分就像一个工厂，我们只需要向工厂请求一个Luggage实例，然后它就会按照config创建一个Luggage实例，我们不用管Luggage实例是怎么一步一步创建的；实例项目中有些Service是很多年以前写的，有几百个类作为它的底层，假设我们新写了一个API需要实例化这个service,总不可能回头去搞清楚这几百个类的构造函数吧；IOC Container就很完美的解决了这类问题；因为这个架构在要求你写class的时候需要编写响应的config文件，所以你要初始化很久以前的service的时候呢前人都已经写好了config文件了，你直接在用的地方注入这个service就可以了，这大大增加了项目的可维护性降低开发难度</p>
<h2 id="IOC的应用"><a href="#IOC的应用" class="headerlink" title="IOC的应用"></a>IOC的应用</h2><h3 id="Bean生成的简要步骤"><a href="#Bean生成的简要步骤" class="headerlink" title="Bean生成的简要步骤"></a>Bean生成的简要步骤</h3><ol>
<li>Spring启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean注册表。</li>
<li>根据生成的Bean注册表通过反射机制实例化Bean，并装配好Bean之间的依赖关系，为上层提供准备就绪的运行环境。Spring提供一个配置文件描述bean和bean之间的依赖关系，利用Java语言的反射功能实例化bean,并建立bean之间的依赖关系</li>
<li>将生成的Bean实例对象放入Spring容器中。</li>
</ol>
<p><img src="/2019/11/05/Java框架-Spring/IOC%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8.jpg" alt></p>
<h3 id="Spring-IOC支持的功能："><a href="#Spring-IOC支持的功能：" class="headerlink" title="Spring IOC支持的功能："></a>Spring IOC支持的功能：</h3><ol>
<li>依赖注入</li>
<li>依赖检查</li>
<li>自动装配</li>
<li>支持集合</li>
<li>指定初始化方法和销毁方法</li>
<li>支持回调方法</li>
</ol>
<h3 id="Spring-IOC容器的核心接口"><a href="#Spring-IOC容器的核心接口" class="headerlink" title="Spring IOC容器的核心接口"></a>Spring IOC容器的核心接口</h3><p><strong>BeanDefinition</strong>  </p>
<p>  主要是用来描述Bean的定义，Spring容器在启动的时候会将xml或者注解里的bean的定义解析成内部的BeanDefinition</p>
<p><strong>BeanDefinitionRegistry</strong>  </p>
<p>  提供向IOC容器注册BeanDefinition对象的方法 ；</p>
<p>  BeanDefinitionRegistry接口提供了 registerBeanDefinition 用来将我们的BeanDefinition注册到BeanFactory 接口的实现类 DefaultListableBeanFactory中的 beanDefinitionMap里，Spring将bean的定义解析成BeanDefinition之后会通过BeanDefinitionRegistry 以BeanName 为key,BeanDefinition为value存储到beanDefinitionMap里，同时还将BeanName存入到beanDefinitionNames里以便后续Bean的实例化</p>
<p>相关源码：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanDefinitionRegistry extends AliasRegistry &#123;</span><br><span class="line">  void registerBeanDefinition(String var1, BeanDefinition var2) throws BeanDefinitionStoreException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123;</span><br><span class="line">    private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap(256);</span><br><span class="line">    private volatile List&lt;String&gt; beanDefinitionNames = new ArrayList(256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BeanFactory：Spring框架最核心的接口</strong>  </p>
<ul>
<li>提供IOC的配置机制</li>
<li>包含Bean的各种定义，便于实例化Bean</li>
<li>建立Bean之间的依赖关系</li>
<li>Bean生命周期的控制</li>
</ul>
<p><strong>ApplicationContext（继承多个接口）</strong>  </p>
<ul>
<li>继承BeanFactory:能够管理、装配Bean</li>
<li>继承ResourcePatternResolver:能够加载资源文件</li>
<li>继承MessageSource:能够实现国际化功能</li>
<li>继承ApplicationEventPublisher:能够注册监听器，实现监听机制</li>
</ul>
<h4 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h4><p>BeanFactory是Spring框架的基础设施，面向Spring,ApplicationContext面向使用Spring框架的开发者<br>BeanFactory采用了工厂设计模式，负责读取bean配置文档，管理bean的加载，实例化，维护bean之间的依赖关系，负责bean的声明周期。而ApplicationContext除了提供上述BeanFactory所能提供的功能之外，还提供了更完整的框架功能：国际化支持、aop、事务等。<br>同时BeanFactory在解析配置文件时并不会初始化对象,只有在使用对象getBean()才会对该对象进行初始化，而ApplicationContext在解析配置文件时对配置文件中的所有对象都初始化了,getBean()方法只是获取对象的过程。<br>因此我们一般在使用的时候尽量使用ApplicationContext。</p>
<h3 id="Spring中几个重要方法"><a href="#Spring中几个重要方法" class="headerlink" title="Spring中几个重要方法"></a>Spring中几个重要方法</h3><h4 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh 方法"></a>refresh 方法</h4><p>Spring容器在创建好了之后会调用refresh()方法<br>SpringApplication.class 中 refresh的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void refresh(ApplicationContext applicationContext) &#123;</span><br><span class="line">    Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">    ((AbstractApplicationContext)applicationContext).refresh();</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>AbstractApplicationContext.class  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">        Object var1 = this.startupShutdownMonitor;</span><br><span class="line">        synchronized(this.startupShutdownMonitor) &#123;</span><br><span class="line">            //设置Spring容器的启动时间，开启活跃状态，初始化属性与信息，验证环境信息里面必须存在的属性</span><br><span class="line">            this.prepareRefresh();</span><br><span class="line">            //获取beanFactory</span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();</span><br><span class="line">            //设置beanFactory</span><br><span class="line">            this.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                this.postProcessBeanFactory(beanFactory);</span><br><span class="line">                // 处理bean标签扫描bean文件，解析成一个个的bean</span><br><span class="line">                this.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">                //bean的后置处理器</span><br><span class="line">                this.registerBeanPostProcessors(beanFactory);</span><br><span class="line">                //初始化一些国际化相关的属性</span><br><span class="line">                this.initMessageSource();</span><br><span class="line">                //初始化事件的广播器，用于事件发布</span><br><span class="line">                this.initApplicationEventMulticaster();</span><br><span class="line">                //模板方法，方法体为空，不同的Spring容器去重写</span><br><span class="line">                this.onRefresh();</span><br><span class="line">                //注册监听器</span><br><span class="line">                this.registerListeners();</span><br><span class="line">                //实例化BeanFactory中已经被注册未被实例化的所有实例</span><br><span class="line">                this.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">                //初始化生命周期管理器</span><br><span class="line">                this.finishRefresh();</span><br><span class="line">            &#125; catch (BeansException var9) &#123;</span><br><span class="line">                if (this.logger.isWarnEnabled()) &#123;</span><br><span class="line">                    this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.destroyBeans();</span><br><span class="line">                this.cancelRefresh(var9);</span><br><span class="line">                throw var9;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                this.resetCommonCaches();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>为IOC容器以及Bean的生命周期管理提供条件</li>
<li>刷新Spring上下文信息，定义Spring上下文加载流程</li>
</ol>
<h4 id="getBean-方法"><a href="#getBean-方法" class="headerlink" title="getBean 方法"></a>getBean 方法</h4><p>通过AbstractBeanFactoryFactory.class 实现可以按类型获取bean的，也有按名称获取bean的<br><strong>getBean方法的代码逻辑</strong></p>
<ul>
<li>转换beanName</li>
<li>从工厂或者缓存中加载实例</li>
<li>实例化Bean</li>
<li>检测parentBeanFactory</li>
<li>检查初始化Bean的相关的依赖</li>
<li>创建Bean</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><strong>1.Spring的五个作用域</strong></p>
<ul>
<li>singleton:Spring的默认作用域，容器里拥有唯一的Bean实例</li>
<li>prototype:针对每个getBean请求，容器都会创建一个Bean实例</li>
<li>request:为每个Httpp请求创建一个Bean实例</li>
<li>session：会为每个session创建一个Bean实例</li>
<li>globlaSession:会为每个全局Http Session创建一个Bean实例，该作用域仅对Portlet有效</li>
</ul>
<p><strong>2.SpringBean的生命周期</strong></p>
<p>创建过程<br><img src="/2019/11/05/Java框架-Spring/%E5%88%9B%E5%BB%BABean%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt></p>
<p>销毁过程</p>
<ul>
<li>若实现了DisposableBean接口，则会调用destroy方法</li>
<li>若配置了destry-method属性，则会调用其配置的销毁方法</li>
</ul>
<h3 id="bean如何装载到IOC容器中和依赖注入的用法"><a href="#bean如何装载到IOC容器中和依赖注入的用法" class="headerlink" title="bean如何装载到IOC容器中和依赖注入的用法"></a>bean如何装载到IOC容器中和依赖注入的用法</h3><p>第一种方式： 手动装配bean,简单粗暴，但是如果bean多的话是一件非常痛苦的事情  </p>
<ol>
<li><p>创建一个class Person</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class person&#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    //get,set省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个Java的配置文件 ApplicationConfig,主要作用是高速IOC容器如何装配这个bean</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuretion</span><br><span class="line">public class ApplicationConfig&#123;</span><br><span class="line">    @Bean(name=&quot;person&quot;)</span><br><span class="line">    public Person initPerson()&#123;</span><br><span class="line">        Person user = new Person();</span><br><span class="line">        user.setId(1L);</span><br><span class="line">        user.setName(&quot;jack&quot;);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过ApplicationContext来获取bean实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = SpringApplication.run(ProductApplication.class, args);</span><br><span class="line">Person person = ctx.getBean(&quot;Peroson.class&quot;);//通过类型来获取</span><br><span class="line">System.out.println(&quot;Name is &quot;+person.getName);</span><br><span class="line">person.call();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>第二种方式： 以SpringBoot方式扫描装配Bean到IOC容器中  </p>
<ol>
<li><p>对Person进行改动 加入@Component 注解，表明哪个类要被扫描进入到SpringIOC容器中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;Person&quot;)</span><br><span class="line">public class person&#123;</span><br><span class="line">    @Value(&quot;1&quot;)</span><br><span class="line">    private Long id;</span><br><span class="line">    @Value(&quot;Jack&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    //get,set省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现依赖注入 新建 Pet.class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public inteface Pet&#123;</span><br><span class="line">    void move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>创建Pet实现类  Dog  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Dog implements Pet&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void move()&#123;</span><br><span class="line">        System.out.println(&quot;running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>Person中注入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;Person&quot;)</span><br><span class="line">public class person&#123;</span><br><span class="line">    @Value(&quot;1&quot;)</span><br><span class="line">    private Long id;</span><br><span class="line">    @Value(&quot;Jack&quot;)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Pet pet;</span><br><span class="line">    public void call()&#123;</span><br><span class="line">        pet.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果新增一个再增加一个Pet的实现类 Bird ,person.call()调用会报错，不知道该调用哪个实现方法，可以加@Primary 或 @Qualifier 告诉Spring该选择谁</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Primary</span><br><span class="line">public class Bird implements Pet&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void move()&#123;</span><br><span class="line">        System.out.println(&quot;flying&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>再次调用person.call() 就会正常输出 flying</li>
</ol>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="关注点分离：不同的问题交给不同的部分去解决"><a href="#关注点分离：不同的问题交给不同的部分去解决" class="headerlink" title="关注点分离：不同的问题交给不同的部分去解决"></a>关注点分离：不同的问题交给不同的部分去解决</h3><ul>
<li>面向切面变成AOP正是此种技术的体现</li>
<li>通用代码的实现，对应的就是所谓的切面（Aspect）</li>
<li>业务功能代码和切面代码分开后，架构将变得高内聚低耦合</li>
<li>确保功能的完整性：切面最终需要被合并到业务中（Weave）</li>
</ul>
<h3 id="AOP的三种织入方式"><a href="#AOP的三种织入方式" class="headerlink" title="AOP的三种织入方式"></a>AOP的三种织入方式</h3><ul>
<li>编译时织入：需要特殊的Java编译器，AspectJ</li>
<li>类加载时织入：需要特殊的Java编译器，如AspectJ和AspectWerkz</li>
<li>运行时织入：Spring采用的方式，通过动态代理的方式，实现简单</li>
</ul>
<p>一个简单的代码实现：记录请求的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        String sentence = &quot;Hello World&quot;;</span><br><span class="line">        System.out.println(sentence);</span><br><span class="line">        return  sentence;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建切面类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class RequestLogAspect &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(RequestLogAspect.class);</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(public * com.imooc.framework.controller..*.*(..))&quot;)</span><br><span class="line">    public void webLog()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;webLog()&quot;)</span><br><span class="line">    public void doBefore(JoinPoint joinPoint)&#123;</span><br><span class="line">        //接收到请求，记录请求内容</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        //记录下请求内容</span><br><span class="line">        logger.info(&quot;URL: &quot;+ request.getRequestURI().toString());</span><br><span class="line">        logger.info(&quot;IP: &quot; + request.getRemoteAddr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterReturning(returning = &quot;ret&quot; ,pointcut = &quot;webLog()&quot;)</span><br><span class="line">    public void doAfterReturning(Object ret)&#123;</span><br><span class="line">        //处理完请求，返回内容</span><br><span class="line">        logger.info(&quot;RESPONSE: &quot; + ret);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AOP主要名词概念"><a href="#AOP主要名词概念" class="headerlink" title="AOP主要名词概念"></a>AOP主要名词概念</h3><ul>
<li><p>Aspect:通用功能代码的实现，切面  普通的java类RequestLogAspect</p>
</li>
<li><p>Target:被织入Aspect的对象  HelloController</p>
</li>
<li><p>Join Point：可以作为切入点的机会，所有的方法都可以作为切入点  所有方法的执行处，如前面的hello方法</p>
</li>
<li><p>Pointcut:Aspect实际被应用在的Join Point，支持正则</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;execution(public * com.imooc.framework.controller..*.*(..))&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Advice:类里的方法以及这个方法如何织入到目标方法的方式</p>
<ul>
<li>前置通知（Before）</li>
<li>后置通知（AfterReturning）</li>
<li>异常通知（AfterThrowing）</li>
<li>最终通知（After）</li>
<li>环绕通知（Around）</li>
</ul>
</li>
<li><p>Weaving:Aop的实现过程,将切面应用到实际对象从而创建一个新的代理对象的过程</p>
</li>
</ul>
<h3 id="AOP的实现：JdkProxy和Cglib"><a href="#AOP的实现：JdkProxy和Cglib" class="headerlink" title="AOP的实现：JdkProxy和Cglib"></a>AOP的实现：JdkProxy和Cglib</h3><ul>
<li>由AopProxyFactory根据AdvisedSupport对象配置来决定</li>
<li>默认策略如果目标是接口，则用JDKProxy来实现，否则用后者</li>
<li>JDKProxy的核心：InvocationHandler接口和Proxy类</li>
<li>Cglib:以继承的方式动态生成目标类的代理（如果某个类被标记成final它是无法使用Cglib做动态代理的）</li>
<li>JDKProxy:通过Java的内部反射机制实现</li>
<li>Cglib:借助ASM实现，一种能够操作字节码的框架</li>
<li>反射机制在生成类的过程中比较高效</li>
<li>ASM在生成类之后的执行过程中比较高效</li>
</ul>
<h3 id="代理模式：接口-真实实现类-代理类"><a href="#代理模式：接口-真实实现类-代理类" class="headerlink" title="代理模式：接口+真实实现类+代理类"></a>代理模式：接口+真实实现类+代理类</h3><p>简单代码实现：</p>
<ol>
<li>新建一个接口实现pay方法</li>
<li>真实实现类和代理类都要实现该方法</li>
<li>在代理类中注入真实实现类，在代理类的实现方法pay()中调用真实实现类的pay()方法，然后增加做自己的业务逻辑</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Payment&#123;</span><br><span class="line">    void pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public RealPayment implements Payment&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void pay()&#123;</span><br><span class="line">        System.out.println(&quot;作为用户我只关心支付&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public AliPay implements Payment&#123;</span><br><span class="line">    private Payment payment;</span><br><span class="line">    public AliPay(Payment payment)</span><br><span class="line"></span><br><span class="line">    public void beforePay()&#123;</span><br><span class="line">        System.out.println(&quot;从招行取款&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void pay()&#123;</span><br><span class="line">        beforePay()；</span><br><span class="line">        payment.pay();</span><br><span class="line">        afterPay();</span><br><span class="line">    &#125;</span><br><span class="line">    public void afterPay()&#123;</span><br><span class="line">        System.out.println(&quot;支付给慕课网&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Payment proxy = new AliPay(new RealPayment);</span><br><span class="line">proxy.pay();</span><br></pre></td></tr></table></figure>

<h3 id="Spring里的代理模式的实现"><a href="#Spring里的代理模式的实现" class="headerlink" title="Spring里的代理模式的实现"></a>Spring里的代理模式的实现</h3><ul>
<li>真实实现类的逻辑包含在了getBean方法里</li>
<li>getBean方法返回的实际上是Proxy实例</li>
<li>Proxy实例是Spring采用JDK Proxy或CGLIB动态生成的</li>
</ul>
<p>底层逻辑代码实现：<br>AbstractAutoProxyCreator.postProcessAfterInitialization() -&gt; wrapIfNecessary() -&gt;createProxy()-&gt;<br>ProxyFactory.getProxy()-&gt;ProxyCreatorSupport.createAopProxy()-&gt;ProxyCreatorSupport.DefaultAopProxyFactory-&gt;DefaultAopProxyFactory.createAopProxy()  </p>
<p>最终看到生成代理的最底层方法，这里只能说Spring的结构真实太复杂了，层层调用 0.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">    if (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !this.hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        return new JdkDynamicAopProxy(config);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        if (targetClass == null) &#123;</span><br><span class="line">            throw new AopConfigException(&quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? new ObjenesisCglibAopProxy(config) : new JdkDynamicAopProxy(config));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring事务的相关问题"><a href="#Spring事务的相关问题" class="headerlink" title="Spring事务的相关问题"></a>Spring事务的相关问题</h3><ul>
<li>ACID</li>
<li>隔离级别</li>
<li>事务传播</li>
</ul>
<p>可参考 <a href="https://blog.csdn.net/weixin_39625809/article/details/80707695" target="_blank" rel="noopener">什么是事务传播行为</a> </p>
<p>可参考 <a href="https://blog.csdn.net/weixin_38070406/article/details/78157603" target="_blank" rel="noopener">spring的4种事务特性，5种隔离级别，7种传播行为</a> </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Spring/">Spring</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AOP/">AOP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IOC/">IOC</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Java多线程与并发"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/05/Java多线程与并发/">Java多线程与并发</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/05/Java多线程与并发/" class="article-date">
	  <time datetime="2019-11-05T03:19:48.000Z" itemprop="datePublished">November 5, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java多线程与并发/">Java多线程与并发</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><h5 id="进程和线程的由来"><a href="#进程和线程的由来" class="headerlink" title="进程和线程的由来"></a>进程和线程的由来</h5><ol>
<li>串行：初期的计算机智能执行任务，并且需要长时间等待用户输入</li>
<li>批处理：预先将用户的指令集中成清单，批量串行处理用户指令，仍然无法并发执行</li>
<li>进程：进程独占内存空间，保存各自运行的状态，互不干扰可以相互切换，为并发处理任务提供了可能</li>
<li>线程：共享进程的内存资源，相互间切换更快速，支持更细粒度的任务控制，使进程内的子任务得以并发执行</li>
</ol>
<p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p>
<ul>
<li>所有与进程相关的资源都被记录在PCB中</li>
<li>进程是抢占处理机的调度单位；线程属于某个进程，共享其资源</li>
<li>线程只由堆栈寄存器、程序计数器和TCB组成</li>
</ul>
<h5 id="进程和线程的区别-1"><a href="#进程和线程的区别-1" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h5><ul>
<li>线程不能看做独立应用，而进程可以看做独立应用</li>
<li>进程有独立的地址空间，相互不影响，线程只是进程不同的执行路径</li>
<li>线程没有独立的地址空间，多进程的程序比多线程程序健壮</li>
<li>进程的切换比线程的切换开销大</li>
</ul>
<h5 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h5><ul>
<li>Java对操作系统提供的功能进行封装，包括进程和线程</li>
<li>运行一个程序会产生一个进程，进程包含至少一个线程</li>
<li>每个进程对应一个JVM实例，多个线程共享JVM里的堆</li>
<li>Java采用单线程的编程模型，程序会自动创建主线程</li>
<li>主线程可以创建子线程，原则上要后于子线程完成执行</li>
</ul>
<h4 id="线程start和run方法的区别"><a href="#线程start和run方法的区别" class="headerlink" title="线程start和run方法的区别"></a>线程start和run方法的区别</h4><p>start()方法回去调用JVM的StartThread的方法，去创建一个新的子线程，并通过ThreadRun方法去调用run方法</p>
<p><img src="/2019/11/05/Java多线程与并发/start%E5%92%8Crun%E6%96%B9%E6%B3%95%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="关系图"></p>
<ul>
<li>调用start方法会创建一个新的子线程</li>
<li>run方法只是Thread的一个普通方法的调用</li>
</ul>
<h4 id="Thread和Runnable是什么关系"><a href="#Thread和Runnable是什么关系" class="headerlink" title="Thread和Runnable是什么关系"></a>Thread和Runnable是什么关系</h4><ul>
<li>Thread是实现了Runnabela接口的类，使得run支持多线程</li>
<li>因类的单一继承原则，为了提升系统可扩展性推荐业务类实现Runnable接口，将业务逻辑封装在run()方法里<br>例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Thread的使用</span><br><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public MyThread(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for(int i = 0 ; i &lt; 10 ; i ++)&#123;</span><br><span class="line">            System.out.println(&quot;Thread start : &quot; + this.name + &quot;,i= &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试类</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread mt1 = new MyThread(&quot;Thread1&quot;);</span><br><span class="line">        MyThread mt2 = new MyThread(&quot;Thread2&quot;);</span><br><span class="line">        MyThread mt3 = new MyThread(&quot;Thread3&quot;);</span><br><span class="line">        mt1.start();</span><br><span class="line">        mt2.start();</span><br><span class="line">        mt3.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Runable的使用</span><br><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public MyRunnable(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for(int i = 0 ; i &lt; 10 ; i ++)&#123;</span><br><span class="line">            System.out.println(&quot;Thread start : &quot; + this.name + &quot;,i= &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//测试类</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        MyRunnable mr1 = new MyRunnable(&quot;Runnable1&quot;);</span><br><span class="line">        MyRunnable mr2 = new MyRunnable(&quot;Runnable2&quot;);</span><br><span class="line">        MyRunnable mr3 = new MyRunnable(&quot;Runnable3&quot;);</span><br><span class="line">        Thread t1 = new Thread(mr1);</span><br><span class="line">        Thread t2 = new Thread(mr2);</span><br><span class="line">        Thread t3 = new Thread(mr3);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何实现处理线程的返回值"><a href="#如何实现处理线程的返回值" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h4><h5 id="如何给run方法传参"><a href="#如何给run方法传参" class="headerlink" title="如何给run方法传参"></a>如何给run方法传参</h5><ul>
<li>构造函数传参</li>
<li>成员变量传参</li>
<li>回调函数传参</li>
</ul>
<h5 id="如何实现处理线程的返回值-1"><a href="#如何实现处理线程的返回值-1" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h5><ul>
<li>主线程等待法：让主线程循环等待，直到目标子线程返回值</li>
<li>使用Thread类的join()阻塞当前线程以等待子线程处理完毕</li>
<li>通过Callable接口实现：通过FutureTask Or 线程池获取;</li>
</ul>
<p>代码实现：FutureTask获取返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyCallable implements Callable&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception&#123;</span><br><span class="line">        String value=&quot;test&quot;;</span><br><span class="line">        System.out.println(&quot;Ready to work&quot;);</span><br><span class="line">        Thread.currentThread().sleep(5000);</span><br><span class="line">        System.out.println(&quot;task done&quot;);</span><br><span class="line">        return  value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class FutureTaskDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = new FutureTask&lt;String&gt;(new MyCallable());</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">        if(!task.isDone())&#123;</span><br><span class="line">            System.out.println(&quot;task has not finished, please wait!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;task return: &quot; + task.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现：通过线程池获取返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//定义一个线程池</span><br><span class="line">ExecutorService newCacheThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">//提交到线程池</span><br><span class="line">Future&lt;String&gt; feture = newCacheThreadPool.submit(new MyCallable());</span><br><span class="line">if(feture.isDone())&#123;</span><br><span class="line">    System.out.println(&quot;task has not finished,wait&quot;);</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">    System.out.println( feture.get() );</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">&#125; catch (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">        //关闭线程池</span><br><span class="line">        newCacheThreadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用线程池的好处：提交多个实现Callable的类，让线程池并发的执行结果，方便对实现Callable的类做统一管理</p>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p><strong>六个状态</strong><br>线程的六个状态</p>
<ol>
<li><p>新建（New）：创建后尚未启动的线程的状态</p>
</li>
<li><p>运行（Runnable）：包含Running和Ready，处于Running状态的线程位于可运行线程中，等待被线程调度选中，获取CPU的使用权；处于Ready状态的线程位于线程池中，等待被线程调度选中，获取CPU的使用权，Ready状态的线程在获取CPU时间后，就会变成Running状态的线程</p>
</li>
<li><p>无限期等待（Waiting）：不会被分配CPU执行时间，需要显示被唤醒，即：<br> 1）没有设置Timeout参数的Object.wait方法。<br> 2）没有设置Timeout参数的Thread.join方法。<br> 3）LockSupport方法。  </p>
</li>
<li><p>限期等待（Timed Waiting）：在一定时间后会由系统自动唤醒。以下情况会造成限期等待：<br> 1）Thread.sleep()方法<br> 2）设置了Timeout参数的Object.wait()方法<br> 3）设置了Timeout参数的Thread.join()方法<br> 4）LockSupport.parkNanos()方法<br> 5）LockSupport.parkUntil()方法</p>
</li>
<li><p>阻塞状态（Blocked）：等待获取排它锁,在另外一个线程放弃锁的时候发生</p>
</li>
<li><p>结束（Terminated）：已终止线程的状态，线程已经结束执行</p>
</li>
</ol>
<h4 id="sleep-和-wait的区别"><a href="#sleep-和-wait的区别" class="headerlink" title="sleep 和 wait的区别"></a>sleep 和 wait的区别</h4><p><strong>基本的差别</strong><br>sleep是Thread的方法，wait是Object类中定义的方法<br>sleep()方法在任何地方都可以使用<br>wait()方法只能在synchronized方法或synchronized块中使用<br><strong>最本质的区别</strong><br>Thread.sleep只会让出CPU,不会导致锁行为的改变<br>Object.wait不仅让出CPU,也会释放锁已经占有的同步资源锁，所以wait在synchronized中使用才有意义<br>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class WaitSleepDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Object lock = new Object();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;thread A is waiting to get lock&quot;);</span><br><span class="line">                synchronized (lock)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(&quot;thread A get lock&quot;);</span><br><span class="line">                        Thread.sleep(20);</span><br><span class="line">                        System.out.println(&quot;thread A do wait method&quot;);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(&quot;thread A is done&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        try&#123;</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line">        &#125; catch (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;thread B is waiting to get lock&quot;);</span><br><span class="line">                synchronized (lock)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(&quot;thread B get lock&quot;);</span><br><span class="line">                        System.out.println(&quot;thread B is sleeping 10 ms&quot;);</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                        Thread.sleep(2000);</span><br><span class="line">                        System.out.println(&quot;thread B is done&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="notify和notifyall的区别"><a href="#notify和notifyall的区别" class="headerlink" title="notify和notifyall的区别"></a>notify和notifyall的区别</h4><blockquote>
<p>锁池 entryList ：</p>
</blockquote>
<p>  假设线程A已经拥有了某个对象（不是类）的锁，而其它线程B、C想要调用这个对象的synchronized方法（或者块），由于B、C线程在进入对象的synchronized方法（或者块）之前必须先获得该对象锁的拥有权，而该对象的锁目前被线程A锁占有，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池</p>
<blockquote>
<p>等待池 WaitList：</p>
</blockquote>
<p>  假设线程A调用了某个对象的wait方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁</p>
<p>notifyAll 会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会<br>notify 只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</p>
<h4 id="yield函数"><a href="#yield函数" class="headerlink" title="yield函数"></a>yield函数</h4><blockquote>
<p>当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示</p>
</blockquote>
<p>关于 Thread.yield() </p>
<ol>
<li>提示线程调度器表示当前线程可以让出 CPU， 但是调度器可能选择忽略</li>
<li>yield 不会改变当前同步锁的状态</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Runnable yieldTask = new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">                if (i == 5) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t1 = new Thread(yieldTask, &quot;A&quot;);</span><br><span class="line">    Thread t2 = new Thread(yieldTask, &quot;B&quot;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="interrupt-函数"><a href="#interrupt-函数" class="headerlink" title="interrupt 函数"></a>interrupt 函数</h4><h5 id="已经被抛弃的方法"><a href="#已经被抛弃的方法" class="headerlink" title="已经被抛弃的方法"></a>已经被抛弃的方法</h5><ol>
<li>stop（）</li>
<li>suspend（）和resunme（）<br>原因：暴力中断线程，如A调用B的stop去终止B线程，由于A不知道B的运行状态，突然停止将可能导致B的一些清理工作无法完成，stop（）方法执行后会马上释放锁，这可能引发数据不同步的问题</li>
</ol>
<h5 id="目前使用的方法"><a href="#目前使用的方法" class="headerlink" title="目前使用的方法"></a>目前使用的方法</h5><ol>
<li><p>调用interrupt（），通知线程应该中断了<br>1）如果线程处于阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常<br>2）如果线程处于正常活动状态，那么会将该线程的中断标记设置为true。被设置中断标志的线程将继续正常运行，不受影响</p>
</li>
<li><p>需要被调用的线程配合中断<br>1）在正常运行任务时，进程检查本线程的中断标志位，如果被设置了中断标志就自行停止线程<br>2）如果线程处于正常活动状态，那么会将该线程的终端标记设置为true。被设置中断标志的线程将继续正常运行，不受影响</p>
</li>
</ol>
<h4 id="线程状态以及线程状态之间的转换"><a href="#线程状态以及线程状态之间的转换" class="headerlink" title="线程状态以及线程状态之间的转换"></a>线程状态以及线程状态之间的转换</h4><p><img src="/2019/11/05/Java多线程与并发/%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.jpg" alt="线程状态之间的转换"></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java多线程与并发/">Java多线程与并发</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Thread和Runnable/">Thread和Runnable</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interrupt/">interrupt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/notify/">notify</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/start和run/">start和run</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/yield/">yield</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/进程和线程/">进程和线程</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Java垃圾回收之垃圾回收器"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/02/Java垃圾回收之垃圾回收器/">Java垃圾回收之垃圾回收器</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/02/Java垃圾回收之垃圾回收器/" class="article-date">
	  <time datetime="2019-11-02T15:25:09.000Z" itemprop="datePublished">November 2, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/GC相关/">GC相关</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h3><hr>
<blockquote>
<p>Stop-the-World：</p>
<ul>
<li>JVM由于要执行GC而停止了应用程序的执行</li>
<li>任何一种GC算法中都会发生</li>
<li>多数GC优化通过减少Stop-the-world发生的时间来提高程序性能</li>
</ul>
</blockquote>
<blockquote>
<p>Safepoint 垃圾收集器的安全点</p>
<ul>
<li>分析过程中对象引用关系不会发生变化的点</li>
<li>产生Safepoint的地方：方法调用；循环跳转；异常跳转</li>
<li>安全点数量得适中</li>
</ul>
</blockquote>
<h3 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h3><hr>
<h4 id="JVM的运行模式"><a href="#JVM的运行模式" class="headerlink" title="JVM的运行模式"></a>JVM的运行模式</h4><ul>
<li>Server:启动较慢,采用的重量级虚拟机，对程序采用了更多的优化；启动稳定后运行速度比Client快</li>
<li>Client:启动较快</li>
</ul>
<h4 id="垃圾搜集器之间的联系"><a href="#垃圾搜集器之间的联系" class="headerlink" title="垃圾搜集器之间的联系"></a>垃圾搜集器之间的联系</h4><p><img src="/2019/11/02/Java垃圾回收之垃圾回收器/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB.jpg" alt></p>
<h4 id="年轻代垃圾收集器"><a href="#年轻代垃圾收集器" class="headerlink" title="年轻代垃圾收集器"></a>年轻代垃圾收集器</h4><h5 id="Serial收集器（-XX-UseSerialGC-复制算法）"><a href="#Serial收集器（-XX-UseSerialGC-复制算法）" class="headerlink" title="Serial收集器（-XX:UseSerialGC,复制算法）"></a>Serial收集器（-XX:UseSerialGC,复制算法）</h5><ul>
<li>单线程收集，进行垃圾收集时必须暂停所有工作线程</li>
<li>简单高效，Client模式下默认的年轻代收集器  </li>
<li>尽可能缩短垃圾收集时用户线程的停顿时间，停顿时间短适合与用户交互的程序，良好的响应速度能提升用户体验</li>
</ul>
<h5 id="ParNew收集器（-XX-UseParNewGC-复制算法）"><a href="#ParNew收集器（-XX-UseParNewGC-复制算法）" class="headerlink" title="ParNew收集器（-XX:+UseParNewGC,复制算法）"></a>ParNew收集器（-XX:+UseParNewGC,复制算法）</h5><ul>
<li>多线程收集，其余行为、特点和Serial收集器一样</li>
<li>单核执行效率不如Serial,在多核下执行才有优势；默认开启的收集线程数和CPU数量相同</li>
</ul>
<h5 id="Parallel-Scavenge收集器（-XX-UseParallelGC-复制算法）"><a href="#Parallel-Scavenge收集器（-XX-UseParallelGC-复制算法）" class="headerlink" title="Parallel Scavenge收集器（-XX:+UseParallelGC,复制算法）"></a>Parallel Scavenge收集器（-XX:+UseParallelGC,复制算法）</h5><ul>
<li>比起管住用户线程停顿时间，更关注系统的吞吐量，高吞吐量可以高效的利用cpu时间尽可能快完成任务，适合在后台运算而不需要太多交互任务的情况</li>
<li>在多核模式下执行才有优势，Server模式下默认的年轻代收集器  配合自适应调节策略 -XX:+UseAdaptiveSizePolicy 把内存管理的调优任务交给虚拟机完成</li>
</ul>
<blockquote>
<p>吞吐量 = 运行用户代码时间/(运行用户代码时间+垃圾收集时间)  </p>
</blockquote>
<h4 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h4><h5 id="Serial-Old收集器（-XX-UseSerialOldGC-标记-整理算法）"><a href="#Serial-Old收集器（-XX-UseSerialOldGC-标记-整理算法）" class="headerlink" title="Serial Old收集器（-XX:UseSerialOldGC,标记-整理算法）"></a>Serial Old收集器（-XX:UseSerialOldGC,标记-整理算法）</h5><ul>
<li>单线程收集，进行垃圾收集时必须暂停所有工作线程</li>
<li>简单高效，Client模式下默认的老年代收集器</li>
</ul>
<h5 id="Parllel-Old收集器（-XX-UseParallelOldGC-标记-整理算法）"><a href="#Parllel-Old收集器（-XX-UseParallelOldGC-标记-整理算法）" class="headerlink" title="Parllel Old收集器（-XX:+UseParallelOldGC,标记-整理算法）"></a>Parllel Old收集器（-XX:+UseParallelOldGC,标记-整理算法）</h5><ul>
<li>多线程收集，吞吐量优先 进行垃圾收集时必须暂停所有工作线程</li>
<li>单核执行效率不如Serial,在多核下执行才有优势</li>
</ul>
<h5 id="CMS收集器（-XX-UseConcMarkSweepGC-标记-清除算法）"><a href="#CMS收集器（-XX-UseConcMarkSweepGC-标记-清除算法）" class="headerlink" title="CMS收集器（-XX:+UseConcMarkSweepGC,标记-清除算法）"></a>CMS收集器（-XX:+UseConcMarkSweepGC,标记-清除算法）</h5><ol>
<li>初始标记：stop-the-world</li>
<li>并发标记：并发追溯标记，程序不会停顿</li>
<li>并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象</li>
<li>重新标记：暂停虚拟机，扫描CMS堆中剩余对象</li>
<li>并发清理：清理垃圾对象，程序不会停顿</li>
<li>并发重置：重置CMS收集器的数据结构  </li>
</ol>
<p>由于是标记清除算法，会带来内存空间碎片化的问题</p>
<h4 id="G1收集器（-XX-UseG1GC-复制-标记-整理算法）"><a href="#G1收集器（-XX-UseG1GC-复制-标记-整理算法）" class="headerlink" title="G1收集器（-XX:+UseG1GC,复制+标记-整理算法）"></a>G1收集器（-XX:+UseG1GC,复制+标记-整理算法）</h4><p>Garbage Firlst收集器的特点：  </p>
<ol>
<li>并发和并行，使用多个cup缩短stop-the-world的时间，与用户线程并发执行</li>
<li>分代收集，独立管理整个堆</li>
<li>空间整合，解决内存碎片</li>
<li>可预测的停顿</li>
</ol>
<p>Garbage First收集器：  </p>
<ul>
<li>将整个堆内存划分为多个大小相等的Region</li>
<li>年轻代和老年代不再物理隔离</li>
</ul>
<h3 id="问题整理："><a href="#问题整理：" class="headerlink" title="问题整理："></a>问题整理：</h3><p><strong>Object的finalize()方法的作用是否与C++的解析函数作用相同</strong></p>
<ul>
<li>与C++的析构函数不同，析构函数调用确定，而它的是不确定的</li>
<li>将未被引用的对象放置于F-Queue队列</li>
<li>方法执行随时可能被终止</li>
<li>给予对象最后一次重生机会</li>
</ul>
<p>一个例子：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Finalization &#123;</span><br><span class="line">    public static Finalization finalization;</span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize()&#123;</span><br><span class="line">        System.out.println(&quot;Finalized&quot;);</span><br><span class="line">        finalization = this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Finalization f = new Finalization();</span><br><span class="line">        System.out.println(&quot;First print: &quot; + f);</span><br><span class="line">        f = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        try &#123;// 休息一段时间，让上面的垃圾回收线程执行完成</span><br><span class="line">            Thread.currentThread().sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Second print: &quot; + f);</span><br><span class="line">        System.out.println(f.finalization);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java中的强引用，软引用，弱引用，虚引用有什么用？</strong></p>
<blockquote>
<p>强引用（Strong Reference）</p>
<ul>
<li>最普遍的引用：Object obj = new Object()</li>
<li>抛出OutOfMemoryError终止程序也不会回收具有强引用的对象</li>
<li>通过将对象设置为null来弱化引用，使其被回收</li>
</ul>
</blockquote>
<blockquote>
<p>软引用（Soft Reference）:  </p>
<ul>
<li>对象处在有用但非必须的状态  ;</li>
<li>只有当内存空间不足时，GC会回收该引用的内存  ;</li>
<li>可以用来实现高速缓存</li>
</ul>
</blockquote>
<p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stirng str = new String(&quot;abc&quot;);//强引用</span><br><span class="line">SoftRefence&lt;String&gt;softRef = new SoftRefence&lt;String&gt;(str);//弱引用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>弱引用（Weak Reference）</p>
<ul>
<li>非必须的对象，比软引用更弱一些</li>
<li>GC时会被回收</li>
<li>被回收的概率也不大，因为GC线程优先级比较低</li>
<li>适用于引用偶尔被使用且不影响垃圾收集的对象</li>
</ul>
</blockquote>
<blockquote>
<p>虚引用（Phantom Reference）</p>
<ul>
<li>不会决定对象的生命周期</li>
<li>任何时候都可能被垃圾收集器回收</li>
<li>跟踪对象被垃圾收集器回收的活动，起哨兵作用</li>
<li>必须和引用队列ReferenceQueue联合使用  </li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = new String(&quot;abc&quot;);</span><br><span class="line">ReferenceQuence queue = new ReferenceQuence();</span><br><span class="line">PhantomReference ref = new PhantomReference(str,queue)</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/02/Java垃圾回收之垃圾回收器/%E5%90%84%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E6%AF%94.jpg" alt></p>
<p><strong>引用队列（ReferenceQueue）</strong></p>
<ul>
<li>无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达</li>
<li>存储关联的企鹅杯GC的软引用，弱引用以及虚引用</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/GC相关/">GC相关</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/新生代垃圾收集器/">新生代垃圾收集器</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/老年代垃圾收集器/">老年代垃圾收集器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Java垃圾回收之回收算法"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/02/Java垃圾回收之回收算法/">Java垃圾回收之回收算法</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/02/Java垃圾回收之回收算法/" class="article-date">
	  <time datetime="2019-11-02T07:57:27.000Z" itemprop="datePublished">November 2, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/GC相关/">GC相关</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="标记-清除算法（Mark-and-Sweep）"><a href="#标记-清除算法（Mark-and-Sweep）" class="headerlink" title="标记-清除算法（Mark and Sweep）"></a>标记-清除算法（Mark and Sweep）</h4><ul>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存</li>
</ul>
<p><img src="/2019/11/02/Java垃圾回收之回收算法/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg" alt="标记-清除算法.jpg"></p>
<p>缺点：由于标记清除不需要进行对象的移动，并且仅对不存活的对象进行处理。会产生大量不连续的内存碎片。</p>
<h4 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h4><ol>
<li>分为对象面和空闲面</li>
<li>对象在对象面上创建</li>
<li>对象面上的内存不足时，存活的对象被从对象面复制到空闲面</li>
<li>将对象面所有对象内存清除</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li>解决碎片化问题</li>
<li>顺序分配内存，简单高效</li>
<li>适用于对象存活率低的场景（年轻代）</li>
</ul>
<h4 id="标记-整理算法（Compacting）"><a href="#标记-整理算法（Compacting）" class="headerlink" title="标记-整理算法（Compacting）"></a>标记-整理算法（Compacting）</h4><ul>
<li>标记：从根集合进行扫描，对存货的对象进行标记</li>
<li>清除：移动所有存活的对象，切按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>避免内存的不连续行</li>
<li>不用设置两块内存互换</li>
<li>适用于对象存活率高的场景（老年代）</li>
</ul>
<h4 id="分代收集算法（Generational-Collector）"><a href="#分代收集算法（Generational-Collector）" class="headerlink" title="分代收集算法（Generational Collector）"></a>分代收集算法（Generational Collector）</h4><ul>
<li>垃圾回收算法的组合拳</li>
<li>按照对象生命周期的不同划分区域以采取不同的垃圾回收算法</li>
<li>目的：提高JVM的回收效率</li>
</ul>
<h4 id="GC的分类"><a href="#GC的分类" class="headerlink" title="GC的分类"></a>GC的分类</h4><ul>
<li>Minor GC:发生在年轻中的垃圾收集动作，采用复制算法；年轻代是所有Java对象出生的地方</li>
<li>Full GC:与老年代相关</li>
</ul>
<p><img src="/2019/11/02/Java垃圾回收之回收算法/%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%88%86%E5%8C%BA.jpg" alt></p>
<h5 id="年轻代：尽可能快速地收集掉那些生命周期短的对象"><a href="#年轻代：尽可能快速地收集掉那些生命周期短的对象" class="headerlink" title="年轻代：尽可能快速地收集掉那些生命周期短的对象"></a>年轻代：尽可能快速地收集掉那些生命周期短的对象</h5><ul>
<li>Eden区（刚创建的对象）</li>
<li>两个Survivor区（幸存者区）<br>新生代占用1/3堆空间，其中Eden 8/10, from1/10 ,to 1/10<br>老年代 2/3堆空间</li>
</ul>
<p>年轻代垃圾回收的过程：</p>
<p><img src="/2019/11/02/Java垃圾回收之回收算法/%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.jpg" alt></p>
<ol>
<li>对象创建在Eden区，当Eden区满了之后会触发一次Minor GC，把标记为存活的对象复制到Survivor0中，清理所有使用过的Eden区域，存活对象年龄+1；</li>
<li>当Eden区再次被填满，触发回Minor GC，会把Eden区和survivor0区中标记为存活的对象都复制到survivor1中，Eden和Survivor0区域将会被清空，周而复始</li>
<li>当对象达到一定年龄（默认15岁），会成为老年代；对于一些较大的对象，年轻代无法装下，会直接进入老年代</li>
</ol>
<p><strong>对象如何晋升到老年代？</strong> </p>
<ol>
<li>经历一定Minor次数依然存活的对象</li>
<li>Survivor区中或Eden区中存放不下的对象，对象优先在Eden区中分配</li>
<li>新生成的大对象（-XX:+PretenuerSizeThreshold）</li>
</ol>
<p><strong>常用的调优参数</strong> </p>
<ul>
<li>XX:SurvivorRatio:Eden和Survivor的比值，默认8：1</li>
<li>XX:NewRatio:老年代和年轻代大小的比例</li>
<li>MaxTenuringThreshold:对象从年轻代晋升到老年代经过GC次数的最大阈值</li>
</ul>
<h5 id="老年代-存放生命周期较长的对象"><a href="#老年代-存放生命周期较长的对象" class="headerlink" title="老年代:存放生命周期较长的对象"></a>老年代:存放生命周期较长的对象</h5><ul>
<li>标记-清理算法</li>
<li>标记-整理算法 </li>
</ul>
<p>当触发老年代的垃圾回收的时候，会伴随着新生代堆内存的回收，即对整个堆的垃圾回收。</p>
<ol>
<li>Full GC和Major GC</li>
<li>Full GC比Minor GC慢，但执行效率低</li>
</ol>
<p><strong>触发Full GC的条件</strong></p>
<ol>
<li>老年代空间不足</li>
<li>永久代空间不足（JDK8以前的版本）</li>
<li>CMS GC时出现promotion failed,concurrent mode failure</li>
<li>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>调用System.gc()</li>
<li>使用RMI来进行RPC或管的JDK应用，每小时执行1次Full GC</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/GC相关/">GC相关</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/回收算法/">回收算法</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Java垃圾回收之标记算法"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/02/Java垃圾回收之标记算法/">Java垃圾回收之标记算法</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/02/Java垃圾回收之标记算法/" class="article-date">
	  <time datetime="2019-11-02T06:51:55.000Z" itemprop="datePublished">November 2, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/GC相关/">GC相关</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="对象被判定为垃圾的标准"><a href="#对象被判定为垃圾的标准" class="headerlink" title="对象被判定为垃圾的标准"></a>对象被判定为垃圾的标准</h4><ul>
<li>没有被其他对象引用</li>
</ul>
<h4 id="如何判断一个对象不被引用？"><a href="#如何判断一个对象不被引用？" class="headerlink" title="如何判断一个对象不被引用？"></a>如何判断一个对象不被引用？</h4><ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<h5 id="引用计数算法：判断对象的引用数量"><a href="#引用计数算法：判断对象的引用数量" class="headerlink" title="引用计数算法：判断对象的引用数量"></a>引用计数算法：判断对象的引用数量</h5><ul>
<li>通过判断对象的引用数量来决定对象是否可以被回收</li>
<li>每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1</li>
<li>任何引用计数为0的对象实例可以被当做垃圾收集</li>
</ul>
<p>优点：执行效率高，程序执行受影响较小<br>缺点：无法检测出循环引用的情况，导致内存泄漏</p>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>通过判断对象的引用链是否可达来决定对象是否可以被回收<br><img src="/2019/11/02/Java垃圾回收之标记算法/%E5%BC%95%E7%94%A8%E9%93%BE.jpg" alt></p>
<p>比如方法区中的类静态属性引用的对象，是可以作为GC Root的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class House &#123;</span><br><span class="line">    public static Area area = new Area(new Street());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Area里面有一个复合对象Street</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Area &#123;</span><br><span class="line">        private Street street;</span><br><span class="line">    public Area(Street street)&#123;</span><br><span class="line">        this.street = street;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么area 这个静态变量实例就是GC Roots，而Street就类似于Object1 2这些，所以通过Area能找到Street那么它就是可达的。</p>
<h5 id="可作为GC-Root的对象"><a href="#可作为GC-Root的对象" class="headerlink" title="可作为GC Root的对象"></a>可作为GC Root的对象</h5><ul>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li>
<li>方法区中的常量引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>本地方法栈中JNI(Natie方法)的引用对象</li>
<li>活跃线程的引用对象</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/GC相关/">GC相关</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/标记算法/">标记算法</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Java的内存模型常见问题"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/10/30/Java的内存模型常见问题/">Java的内存模型常见问题</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/10/30/Java的内存模型常见问题/" class="article-date">
	  <time datetime="2019-10-30T14:57:48.000Z" itemprop="datePublished">October 30, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="JVM三大性能调优参数-Xms-Xmx-Xss的含义"><a href="#JVM三大性能调优参数-Xms-Xmx-Xss的含义" class="headerlink" title="JVM三大性能调优参数-Xms -Xmx -Xss的含义"></a>JVM三大性能调优参数-Xms -Xmx -Xss的含义</h4><ol>
<li>-Xss：规定的每个虚拟机栈（堆栈）的大小。一般情况下，256K足够。此配置将会影响此进程中并发线程数的大小</li>
<li>-Xms：初始java堆的大小，即该进程刚创建出来的时候java堆的大小。</li>
<li>-Xmx：一旦对象容量超过-Xms大小，则将java堆大小扩容至改参数。为防止heap扩容导致内存抖动，影响程序运行稳定性，一般设置成与Xms一样大小</li>
</ol>
<h4 id="Java内存模型中堆和栈的区别"><a href="#Java内存模型中堆和栈的区别" class="headerlink" title="Java内存模型中堆和栈的区别"></a>Java内存模型中堆和栈的区别</h4><h5 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><p>静态存储：编译时确定每个数据目标在运行时的存储空间需求<br>栈式存储：数据区需求在编译时未知，运行时模块入口前确定<br>堆时存储：编译时或运行时模块入口都无法确定，动态分配</p>
<h4 id="Java内存模型中堆和栈的区别-1"><a href="#Java内存模型中堆和栈的区别-1" class="headerlink" title="Java内存模型中堆和栈的区别"></a>Java内存模型中堆和栈的区别</h4><p>联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址<br>管理方式：栈自动释放，堆需要GC<br>空间大小：栈比堆小<br>碎片相关：栈产生的碎片远小于堆<br>分配方式：栈支持静态和动态分配，而堆仅支持动态分配<br>效率：栈的效率比堆高</p>
<h4 id="元空间、堆、线程独占部分间的联系-内存角度"><a href="#元空间、堆、线程独占部分间的联系-内存角度" class="headerlink" title="元空间、堆、线程独占部分间的联系-内存角度"></a>元空间、堆、线程独占部分间的联系-内存角度</h4><p><img src="/2019/10/30/Java的内存模型常见问题/%E5%85%83%E7%A9%BA%E9%97%B4%E5%A0%86%E7%BA%BF%E7%A8%8B%E7%8B%AC%E5%8D%A0%E9%83%A8%E5%88%86%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB.jpg" alt></p>
<h4 id="不同JDK版本之间的intern-方法的区别——JDK6-VS-JDK6"><a href="#不同JDK版本之间的intern-方法的区别——JDK6-VS-JDK6" class="headerlink" title="不同JDK版本之间的intern()方法的区别——JDK6 VS JDK6+"></a>不同JDK版本之间的intern()方法的区别——JDK6 VS JDK6+</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stirng s = new String (&quot;a&quot;);</span><br><span class="line">s.intern();</span><br></pre></td></tr></table></figure>

<p><strong>JDK6:</strong> 当调用intern 方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中的该字符串的引用。否则，将此字符串对象添加到字符串常量池中，并且返回该字符串对象的引用<br><strong>JDK6+:</strong> 当调用intern 方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中的该字符串的引用。否则，如果该字符串对象已经存在于java堆中，则将堆中对此对象的引用添加到字符串常量池中，并且返回该引用；如果堆中不存在，则在池中创建该字符串并返回其引用 </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JVM/">JVM</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Java内存模型"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/10/30/Java内存模型/">Java内存模型</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/10/30/Java内存模型/" class="article-date">
	  <time datetime="2019-10-30T06:01:08.000Z" itemprop="datePublished">October 30, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="内存简介"><a href="#内存简介" class="headerlink" title="内存简介"></a>内存简介</h4><p>计算机所有程序都是内存中运行的。在程序执行过程中，需要不断的将内存的逻辑地址和物理地址相互映射，找到相关的指令以及数据去执行。作为操作系统进程，java运行时受限于操作系统架构提供的可寻址空间。操作系统架构的可寻址空间由系统位数决定。</p>
<ul>
<li>32位处理器：2^32的可寻址范围</li>
<li>64位处理器：2^64的可寻址范围<h5 id="地址空间的划分"><a href="#地址空间的划分" class="headerlink" title="地址空间的划分"></a>地址空间的划分</h5>内核空间<br>用户空间</li>
</ul>
<h4 id="JVM内存模型-JDK8"><a href="#JVM内存模型-JDK8" class="headerlink" title="JVM内存模型-JDK8"></a>JVM内存模型-JDK8</h4><p><img src="/2019/10/30/Java内存模型/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" alt></p>
<ul>
<li>线程私有：程序计数器、虚拟机栈、本地方法栈</li>
<li>线程共享：MetaSpace、Java堆</li>
</ul>
<h4 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h4><ol>
<li><p>程序计数器（逻辑的），是当前线程所执行的字节码的行号指示器。</p>
</li>
<li><p>改变计数器的值来选取下一条需要执行的字节码命令</p>
</li>
<li><p>和线程是一对一的关系即“线程私有” 。由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程独立存储，这种内存区域为“线程私有”的内存。</p>
</li>
<li><p>如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。</p>
</li>
<li><p>因为只计数，所以不用担心内存泄露的问题</p>
</li>
</ol>
<h4 id="Java虚拟机栈（Stack）"><a href="#Java虚拟机栈（Stack）" class="headerlink" title="Java虚拟机栈（Stack）"></a>Java虚拟机栈（Stack）</h4><ul>
<li>Java 方法执行的内存模型</li>
<li>每个方法执行时都会创建一个栈帧，包含多个栈帧。Java 虚拟机栈用来存储栈帧，栈帧持有局部变量和部分结果以及参与方法的调用与返回，方法调用结束时帧才会被销毁<br><img src="/2019/10/30/Java内存模型/Stack.jpg" alt></li>
</ul>
<p>局部变量表：包含方法执行过程中的所有变量<br>操作数栈：入栈、出栈、复制、交换、产生消费变量</p>
<p> <img src="/2019/10/30/Java内存模型/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E5%92%8C%E6%93%8D%E4%BD%9C%E6%A0%91%E6%A0%88%E7%9A%84%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B.jpg" alt="局部变量表和操作树栈的交互过程"></p>
<h5 id="递归引发java-lang-StackOverflowError异常"><a href="#递归引发java-lang-StackOverflowError异常" class="headerlink" title="递归引发java.lang.StackOverflowError异常"></a>递归引发java.lang.StackOverflowError异常</h5><p>  <img src="/2019/10/30/Java内存模型/StackOverfolwError.jpg" alt="局部变量表和操作树栈的交互过程"><br>原因：递归层数过多，当线程执行一个方法时就随之创建一个对应的栈帧，并将建立的栈帧压入虚拟机栈中，当方法执行完毕的时候便会当栈帧出栈，因此可知线程当前执行的方法所对应的的栈帧必定位于Java栈的顶部，而我们的递归函数不断去调用自身，每一次方法调用会涉及：第一，每新调用一次方法就会生成一个栈帧<br>第二,它会保存当前方法的栈帧状态将它放到虚拟机栈中<br>第三,栈帧上下文切换的时候会切换到最新的方法栈帧当中，而由于我们每个线程虚拟机栈深度是固定的，递归实现将导致栈的深度增加，每次递归都会往栈里压入一个栈帧，如果超出的最大允许的深度就会报StackOverfolwError</p>
<h5 id="虚拟机栈过多引发java-lang-OutOfMemoryError异常"><a href="#虚拟机栈过多引发java-lang-OutOfMemoryError异常" class="headerlink" title="虚拟机栈过多引发java.lang.OutOfMemoryError异常"></a>虚拟机栈过多引发java.lang.OutOfMemoryError异常</h5><p>当虚拟机栈可以自动扩展但是无法申请到新的内存空间时就会抛出java.lang.OutOfMemoryError异常<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void stackLeakByThread()&#123;</span><br><span class="line">  while(true)&#123;</span><br><span class="line">    new Thread()&#123;</span><br><span class="line">      public void run()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p> 与虚拟机栈相似，主要用于标注了native方法</p>
<h4 id="元空间（MetaSpace）"><a href="#元空间（MetaSpace）" class="headerlink" title="元空间（MetaSpace）"></a>元空间（MetaSpace）</h4><p>元空间和永久代都是用来存储class的相关信息包括class对象的method和field等  ;在8以后使用元空间（使用本地内存）替代永久代（使用JVM内存）,原先位于方法区的字符串常量池被移到堆中 ;元空间和永久代均是方法区的实现，方法区只是JVM的规范</p>
<h5 id="元空间（MetaSpace）与永久代（PermGen）的区别"><a href="#元空间（MetaSpace）与永久代（PermGen）的区别" class="headerlink" title="元空间（MetaSpace）与永久代（PermGen）的区别"></a>元空间（MetaSpace）与永久代（PermGen）的区别</h5><ul>
<li>元空间使用本地内存，而永久代使用的是JVM的内存</li>
</ul>
<h5 id="MetaSpace相比PermGen的优势"><a href="#MetaSpace相比PermGen的优势" class="headerlink" title="MetaSpace相比PermGen的优势"></a>MetaSpace相比PermGen的优势</h5><ol>
<li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li>
<li>类和方法的信息大小难以确定，给永久代的大小指定带来困难</li>
<li>永久代会为GC带来不必要的复杂性</li>
<li>方便HotSpot与其它JVM如Jrockit的集成,永久代是HotSpot VM特有的，别的VM没有永久代</li>
</ol>
<h4 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h4><ol>
<li>对象实例的分配区域</li>
<li>GC管理的主要区域</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JVM/">JVM</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程共享/">线程共享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/线程独占/">线程独占</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-谈谈ClassLoader"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/10/26/谈谈ClassLoader/">谈谈ClassLoader</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/10/26/谈谈ClassLoader/" class="article-date">
	  <time datetime="2019-10-26T03:40:31.000Z" itemprop="datePublished">October 26, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="类从编译到执行的过程"><a href="#类从编译到执行的过程" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h4><ol>
<li>编译器将Robot.java源文件编译为Robot.class字节码文件</li>
<li>ClassLoader将字节码转化为JVM中的 Class&lt; Robot &gt;对象</li>
<li>JVM利用Class&lt; Robot &gt;对象实例化为Robot对象</li>
</ol>
<h4 id="谈谈ClassLoader"><a href="#谈谈ClassLoader" class="headerlink" title="谈谈ClassLoader"></a>谈谈ClassLoader</h4><p>ClassLoader主要工作在Class装载的加载阶段，主要作用是从系统外部获取Class二进制数据流。<br>它是Java的核心组件，所有的Class都是由ClassLoader进行加载的，负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接，初始化等操作。</p>
<h5 id="ClassLoader-的种类"><a href="#ClassLoader-的种类" class="headerlink" title="ClassLoader 的种类"></a>ClassLoader 的种类</h5><ul>
<li>BootStrapClassLoader：C++编写，加载核心库 java.*</li>
<li>ExtClassLoader：Java编写，加载扩展库javaa.*</li>
<li>AppClassLoader：Java编写，加载程序所在目录</li>
<li>自定义ClassLoader：Java编写，定制化加载 可能不在系统classpath范围内</li>
</ul>
<h5 id="ClassLoader双亲委派机制"><a href="#ClassLoader双亲委派机制" class="headerlink" title="ClassLoader双亲委派机制"></a>ClassLoader双亲委派机制</h5><ol>
<li>自底而上检查类是否已经加载<br>Custom ClassLoader–App ClassLoader–Extension   ClassLoader–BootStrap ClassLoader  </li>
<li>自上而下尝试加载类<br>BootStrap:加载 jre\lib\rt.jar 或者 Xbootclasspath选项指定的jar包<br>Extension:加载 jre\lib\ext*.jar 或者 Djava.ext.dirs指定目录下的jar包<br>App: 加载ClassPath 或者 Djava.class.path所指定的目录下的类和jar包</li>
</ol>
<p><img src="/2019/10/26/谈谈ClassLoader/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.jpg" alt></p>
<h5 id="为什么使用双亲委派机制"><a href="#为什么使用双亲委派机制" class="headerlink" title="为什么使用双亲委派机制"></a>为什么使用双亲委派机制</h5><p> 避免多份同样字节码的加载</p>
<h4 id="类的装载过程"><a href="#类的装载过程" class="headerlink" title="类的装载过程"></a>类的装载过程</h4><ol>
<li>加载：通过ClassLoader加载class文件字节码生成Class对象</li>
<li>链接：<ul>
<li>校验：检查加载的class的正确性和安全性</li>
<li>准备：为类变量分配存储空间并设置类变量初始值</li>
<li>解析：JVM将常量池内的符号引用转换为直接引用</li>
</ul>
</li>
<li>初始化：执行类变量赋值和静态代码块</li>
</ol>
<h4 id="loadClass和forName的区别"><a href="#loadClass和forName的区别" class="headerlink" title="loadClass和forName的区别"></a>loadClass和forName的区别</h4><p>Class.forName是类加载到初始化的步骤<br>Classloader.loadClass是刚执行完加载class</p>
<h5 id="Class-forName已完成初始化，那为什么还要用LoadClass呢？"><a href="#Class-forName已完成初始化，那为什么还要用LoadClass呢？" class="headerlink" title="Class.forName已完成初始化，那为什么还要用LoadClass呢？"></a>Class.forName已完成初始化，那为什么还要用LoadClass呢？</h5><p>存在即合理；<br>LoadClass在springIOC中资源加载器获取要读入的资源的时候，即读取一些bean的配置文件的时候，如果是以classPath方式来加载的话 就需要使用Classload.loadClass来加载，之所以这样做是和springIOC的lazy-loading（懒加载）有关，springIOC为了加快初始化速度因此大量使用延迟加载技术而使用ClassLoad不需要执行类中的初始化代码（static）步骤和链接步骤，这样子做可以加快加载速度 ，把类的初始化工作留到实际使用到这个类的时候才去做.</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JVM/">JVM</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ClassLoader/">ClassLoader</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/类的装载/">类的装载</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-JVM如何加载class文件"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/10/26/JVM如何加载class文件/">JVM如何加载class文件</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/10/26/JVM如何加载class文件/" class="article-date">
	  <time datetime="2019-10-26T01:53:49.000Z" itemprop="datePublished">October 26, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h4><p>Java虚拟机：抽象化的计算机，通过在实际的计算机上个仿真模拟计算机功能来实现的，有自己完善的硬件架构：处理器，堆栈，寄存器等，还具有相应的指令系统，jvm 屏蔽了与具体操作系统平台相关的信息，使得java程序只需要生成在java虚拟机上运行的字节码，就可以在不同平台上不加修改的运行。其中最重要的两点：JVM内存结构模型，GC  </p>
<p><em>jvm是内存中的虚拟机，jvm的存储就是内存，所有写的 类，常量，变量，方法都在内存中这决定着程序的健壮和高效</em></p>
<p><img src="/2019/10/26/JVM如何加载class文件/Java%E8%99%9A%E6%8B%9F%E6%9C%BA.jpg" alt></p>
<ol>
<li>Class Loader ： 依据特定格式，加载class文件到内存  </li>
<li>Runtime Data Area ：JVM内存空间结构模型</li>
<li>Native Interface: 融合不同开发语言的原生库为Java所用</li>
<li>Execution Engine ：对命令进行解析</li>
</ol>
<p>JVM结构：  Class Loader, Runtime Data Area, Execution Engine, Native Interface</p>
<hr>
<h4 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h4><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。  </p>
<h5 id="写一个反射的例子"><a href="#写一个反射的例子" class="headerlink" title="写一个反射的例子"></a>写一个反射的例子</h5><p>Robot.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.interview.javabasic.reflect</span><br><span class="line"></span><br><span class="line">public class Robot&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void sayHi(String helloSentence)&#123;</span><br><span class="line">        System.out.println(helloSentence + &quot;&quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    private String throwHello(String tag)&#123;</span><br><span class="line">        return &quot;Hello&quot; + tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReflectSample.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    //先获取Robot类，需要全路径</span><br><span class="line">    Class rc = Class.forNam(&quot;com.interview.javabasic.reflect.Robot&quot;)</span><br><span class="line">    //创建实例,需要强转，newInstance返回的是泛型</span><br><span class="line">    Robot r = (Robot)rc.newInstance();</span><br><span class="line">    System.out.println(&quot;Class name is &quot; + rc.getName());</span><br><span class="line">    //通过反射获取私有方法,throwHello接收一个String类型的参数</span><br><span class="line">    Method getHello = rc.getDeclaredMethod( name: &quot;throwHello&quot;,String.class)；</span><br><span class="line">    getHello.setAccessible(true);</span><br><span class="line">    //需要传入对象实例，和方法参数</span><br><span class="line">    Object str = getHello.invoke(r,&quot;Bob&quot;);</span><br><span class="line">    System.out.println(&quot;getHello result is &quot; + str);</span><br><span class="line">    //第二种获取方法获取方法</span><br><span class="line">    Method sayHi = rc.getMethod( name: &quot;sayHi&quot;,String.class)；</span><br><span class="line">    sayHi.invoke(r,&quot;Welcome&quot;);</span><br><span class="line">    //获取私有类型的Filed</span><br><span class="line">    Filed name = rc.getDeclaredField(name: &quot;name&quot;);</span><br><span class="line">    name.setAccessible(true);</span><br><span class="line">    name.set(r,&quot;Alice&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Metohd:</strong><br>newInstance()方法返回的是泛型。<br>getDeclaredMethod可以获得该类所有的方法，除去继承和实现了接口的方法。<br>如果是私有的方法，必须使用setAccessible(true)方法。<br>getMethod可以获得该类所有的公有方法，还有所继承的以及实现了接口的方法。  </p>
<p><strong>Field:</strong><br>getDeclaredField获取属性<br>如果是私有属性也要设置setAccessible(true)  </p>
<hr>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JVM/">JVM</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM内存结构模型/">JVM内存结构模型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/反射/">反射</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-谈谈我对Java的理解"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/10/25/谈谈我对Java的理解/">谈谈我对Java的理解</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/10/25/谈谈我对Java的理解/" class="article-date">
	  <time datetime="2019-10-25T08:23:12.000Z" itemprop="datePublished">October 25, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JVM/">JVM</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="谈谈我对Java的理解"><a href="#谈谈我对Java的理解" class="headerlink" title="谈谈我对Java的理解"></a>谈谈我对Java的理解</h4><p>从以下几个点进行扩展  </p>
<p>平台无关性：一次编译到处运行<br>GC垃圾回收：不用手动释放内存<br>语言特性：泛型、lamda、反射<br>面向对象：封装、继承、多态<br>类库：自带的集合和并发库<br>异常处理  </p>
<h4 id="Compile-Once-Run-Anywhere如何实现（如何实现平台无关的）？"><a href="#Compile-Once-Run-Anywhere如何实现（如何实现平台无关的）？" class="headerlink" title="Compile Once,Run Anywhere如何实现（如何实现平台无关的）？"></a>Compile Once,Run Anywhere如何实现（如何实现平台无关的）？</h4><p>编译时：javac   (查看字节码 javac -p)<br>运行时：java<br>.java文件首先经过javac编译生成字节码。将字节码保存在.class文件中。.class文件是跨平台的基础。再由不同平台的JVM进行解析，java语言在不同的平台上运行时不需要进行重新编译，java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令。</p>
<p><img src="/2019/10/25/谈谈我对Java的理解/%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E5%88%B0%E5%A4%84%E8%BF%90%E8%A1%8C.png" alt></p>
<h4 id="为什么jvm不直接执行源码，而是将字节码解析成机器码才去执行"><a href="#为什么jvm不直接执行源码，而是将字节码解析成机器码才去执行" class="headerlink" title="为什么jvm不直接执行源码，而是将字节码解析成机器码才去执行"></a>为什么jvm不直接执行源码，而是将字节码解析成机器码才去执行</h4><ol>
<li>每次执行都需要各种检查（语法，句法，语义的检查，每次执行的时候，这些语义分析结果不会被保留下来。因此引入字节码，在每次执行程序是不需要各种校验和补全的）</li>
<li>兼容性，可以将别的语言（groovy,scala）解析成字节码</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JVM/">JVM</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java特性/">Java特性</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/平台无关性/">平台无关性</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" Search…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="Search">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Connect With Us</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/ValarMorghulis521" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="http://weibo.com/chenshifouaili" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>Recent Posts</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/12/20/一些好句子/">一些好句子</a></h6>
              <span>December 20, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/12/18/设计模式/">设计模式</a></h6>
              <span>December 18, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/19/容器部署/">容器部署</a></h6>
              <span>November 19, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/18/链路监控/">链路监控</a></h6>
              <span>November 18, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/18/服务容错Hystrix/">服务容错Hystrix</a></h6>
              <span>November 18, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/16/Zuul/">Zuul</a></h6>
              <span>November 16, 2019</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GC相关/">GC相关</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java多线程与并发/">Java多线程与并发</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java常用类库与技巧/">Java常用类库与技巧</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Boot-实战/">Spring Boot 实战</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务实战/">微服务实战</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACID/">ACID</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOF/">AOF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/">AOP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ClassLoader/">ClassLoader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Config-Clent/">Config Clent</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Config-Server/">Config Server</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cookie和动态路由/">Cookie和动态路由</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eureka/">Eureka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hashtable/">Hashtable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hystrix/">Hystrix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOC/">IOC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO机制/">IO机制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/InnoDB/">InnoDB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/J-U-C包的梳理/">J.U.C包的梳理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM内存结构模型/">JVM内存结构模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java特性/">Java特性</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/List/">List</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyISAM/">MyISAM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OSI七层模型/">OSI七层模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RDB/">RDB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RTO/">RTO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RTT/">RTT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/">RabbitMQ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Set/">Set</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cliud-Stream/">Spring Cliud Stream</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud-Bus/">Spring Cloud Bus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud-Sleuth/">Spring Cloud Sleuth</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP的三次握手/">TCP的三次握手</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP的四次挥手/">TCP的四次挥手</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thread和Runnable/">Thread和Runnable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UDP/">UDP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zipkin/">Zipkin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zuul/">Zuul</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interrupt/">interrupt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lombok/">lombok</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/notify/">notify</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql调优/">sql调优</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/start和run/">start和run</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yield/">yield</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代理模式/">代理模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式锁/">分布式锁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单例模式/">单例模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/反射/">反射</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回收算法/">回收算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多路I-O复用模型/">多路I/O复用模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/密集索引/">密集索引</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工厂模式/">工厂模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/平台无关性/">平台无关性</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异常/">异常</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步队列/">异步队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/当前读/">当前读</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快照读/">快照读</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库事务/">数据库事务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库架构/">数据库架构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/新生代垃圾收集器/">新生代垃圾收集器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日志框架/">日志框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务容错/">服务容错</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务网关/">服务网关</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/标记算法/">标记算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/滑动窗口/">滑动窗口</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/稀疏索引/">稀疏索引</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/类的装载/">类的装载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/索引/">索引</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/索引数据结构/">索引数据结构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程共享/">线程共享</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程独占/">线程独占</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/老年代垃圾收集器/">老年代垃圾收集器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/语法/">语法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域/">跨域</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/进程和线程/">进程和线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/鉴权/">鉴权</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链路监控/">链路监控</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/锁模块/">锁模块</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/限流/">限流</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ACID/" style="font-size: 10px;">ACID</a> <a href="/tags/AOF/" style="font-size: 10px;">AOF</a> <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/ClassLoader/" style="font-size: 10px;">ClassLoader</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 10px;">ConcurrentHashMap</a> <a href="/tags/Config-Clent/" style="font-size: 10px;">Config Clent</a> <a href="/tags/Config-Server/" style="font-size: 10px;">Config Server</a> <a href="/tags/Cookie和动态路由/" style="font-size: 10px;">Cookie和动态路由</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Eureka/" style="font-size: 10px;">Eureka</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/Hashtable/" style="font-size: 10px;">Hashtable</a> <a href="/tags/Hystrix/" style="font-size: 10px;">Hystrix</a> <a href="/tags/IOC/" style="font-size: 10px;">IOC</a> <a href="/tags/IO机制/" style="font-size: 10px;">IO机制</a> <a href="/tags/InnoDB/" style="font-size: 10px;">InnoDB</a> <a href="/tags/J-U-C包的梳理/" style="font-size: 10px;">J.U.C包的梳理</a> <a href="/tags/JVM内存结构模型/" style="font-size: 10px;">JVM内存结构模型</a> <a href="/tags/Java特性/" style="font-size: 10px;">Java特性</a> <a href="/tags/List/" style="font-size: 10px;">List</a> <a href="/tags/MyISAM/" style="font-size: 10px;">MyISAM</a> <a href="/tags/OSI七层模型/" style="font-size: 10px;">OSI七层模型</a> <a href="/tags/RDB/" style="font-size: 10px;">RDB</a> <a href="/tags/RTO/" style="font-size: 10px;">RTO</a> <a href="/tags/RTT/" style="font-size: 10px;">RTT</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Set/" style="font-size: 10px;">Set</a> <a href="/tags/Spring-Cliud-Stream/" style="font-size: 10px;">Spring Cliud Stream</a> <a href="/tags/Spring-Cloud-Bus/" style="font-size: 10px;">Spring Cloud Bus</a> <a href="/tags/Spring-Cloud-Sleuth/" style="font-size: 10px;">Spring Cloud Sleuth</a> <a href="/tags/TCP的三次握手/" style="font-size: 10px;">TCP的三次握手</a> <a href="/tags/TCP的四次挥手/" style="font-size: 10px;">TCP的四次挥手</a> <a href="/tags/Thread和Runnable/" style="font-size: 10px;">Thread和Runnable</a> <a href="/tags/UDP/" style="font-size: 10px;">UDP</a> <a href="/tags/Zipkin/" style="font-size: 10px;">Zipkin</a> <a href="/tags/Zuul/" style="font-size: 10px;">Zuul</a> <a href="/tags/interrupt/" style="font-size: 10px;">interrupt</a> <a href="/tags/lombok/" style="font-size: 10px;">lombok</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/notify/" style="font-size: 10px;">notify</a> <a href="/tags/sql调优/" style="font-size: 10px;">sql调优</a> <a href="/tags/start和run/" style="font-size: 10px;">start和run</a> <a href="/tags/yield/" style="font-size: 10px;">yield</a> <a href="/tags/代理模式/" style="font-size: 10px;">代理模式</a> <a href="/tags/分布式锁/" style="font-size: 10px;">分布式锁</a> <a href="/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/tags/反射/" style="font-size: 10px;">反射</a> <a href="/tags/回收算法/" style="font-size: 10px;">回收算法</a> <a href="/tags/多路I-O复用模型/" style="font-size: 10px;">多路I/O复用模型</a> <a href="/tags/密集索引/" style="font-size: 10px;">密集索引</a> <a href="/tags/工厂模式/" style="font-size: 10px;">工厂模式</a> <a href="/tags/平台无关性/" style="font-size: 10px;">平台无关性</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/异步队列/" style="font-size: 10px;">异步队列</a> <a href="/tags/当前读/" style="font-size: 10px;">当前读</a> <a href="/tags/快照读/" style="font-size: 10px;">快照读</a> <a href="/tags/数据库事务/" style="font-size: 10px;">数据库事务</a> <a href="/tags/数据库架构/" style="font-size: 10px;">数据库架构</a> <a href="/tags/新生代垃圾收集器/" style="font-size: 10px;">新生代垃圾收集器</a> <a href="/tags/日志框架/" style="font-size: 10px;">日志框架</a> <a href="/tags/服务容错/" style="font-size: 10px;">服务容错</a> <a href="/tags/服务网关/" style="font-size: 10px;">服务网关</a> <a href="/tags/标记算法/" style="font-size: 10px;">标记算法</a> <a href="/tags/滑动窗口/" style="font-size: 10px;">滑动窗口</a> <a href="/tags/稀疏索引/" style="font-size: 10px;">稀疏索引</a> <a href="/tags/类的装载/" style="font-size: 10px;">类的装载</a> <a href="/tags/索引/" style="font-size: 15px;">索引</a> <a href="/tags/索引数据结构/" style="font-size: 10px;">索引数据结构</a> <a href="/tags/线程共享/" style="font-size: 10px;">线程共享</a> <a href="/tags/线程独占/" style="font-size: 10px;">线程独占</a> <a href="/tags/老年代垃圾收集器/" style="font-size: 10px;">老年代垃圾收集器</a> <a href="/tags/语法/" style="font-size: 10px;">语法</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/进程和线程/" style="font-size: 10px;">进程和线程</a> <a href="/tags/鉴权/" style="font-size: 10px;">鉴权</a> <a href="/tags/链路监控/" style="font-size: 10px;">链路监控</a> <a href="/tags/锁模块/" style="font-size: 20px;">锁模块</a> <a href="/tags/限流/" style="font-size: 10px;">限流</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">25</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>

    <div>
	<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=22805088&auto=0&height=66"></iframe>
  </div>
  </div>


  
</aside>

        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 Contunued Story All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
      var headerblur = document.getElementById("header-blur");
      headerblur.style.minHeight = window.getComputedStyle(document.getElementById("allheader"), null).height;
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true,"scale":0.5},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
