<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP与HTTPS的区别]]></title>
    <url>%2F2019%2F10%2F08%2FHTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[HTTPS 简介 HTTP HTTPS HTTP HTTP SSL OR TLS TCP TCP IP IP HTTPS:以计算机网络通信安全为目的的传输协议 SSL(Security Sockets Layer,安全套接层) 为网络通信提供安全及数据完整性一种安全协议 是操作系统对外API ,SSL3.0 后更名为TLS 采用身份验证和数据加密保证网络通信安全和数据完整性HTTP数据传输流程 浏览器将支持的加密算法发送给服务器 服务器选择一套浏览器支持的加密算法，以证书形式回发给浏览器 浏览器验证证书合法性，结合证书公钥加密信息发送给服务器 服务器使用私钥解密，验证哈希加密响应消息回发浏览器 浏览器解密响应消息，对消息进行验真，之后进行加密交换数据 区别 HTTPS需要到CA申请证书，HTTP不需要 HTTP超文本传输协议明文传输，HTTPS密文传输，HTTPS基于具有安全性的SSL加密 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口 HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP相关]]></title>
    <url>%2F2019%2F10%2F06%2FHTTP%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[超文本传输协议HTTP主要特点 支持客户/服务器模式 简单快速 灵活 无连接 无状态 请求/响应的步骤 客户端连接到web服务器 发送HTTP请求 服务器接受请求并返回HTTP响应 释放连接TCP连接 客户端浏览器解析HTML内容 在浏览器地址键入URL，按下回车之后经历的流程 DNS解析 浏览器依据URL逐层查询DNS服务器缓存，解析URL中的域名所对应的的IP TCP连接 找到IP地址后根据IP和对应端口和服务器建立TCP连接，结合三次握手讲解 浏览器发送HTTP请求 服务器处理请求并返回HTTP响应报文 浏览器解析渲染页面 连接结束 结合四次挥手HTTP状态码五种可能的取值 1XX : 指示信息 – 表示请求已接收，继续处理 2XX : 成功–表示请求已被成功接收、理解、接受 3XX : 重定向 – 要完成请求必须进行更进一步的操作 4xx : 客户端错误 – 请求有语法错误或请求无法实现 5XX : 服务器端错误–服务器未能实现合法的请求常见状态码 200 OK : 正常返回信息 400 Bad Request : 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized : 请求未经授权，这个状态码必须和WWW-Authenticate 报头域一起使用 403 Forbidden : 服务器收到请求，但是拒绝提供服务 404 Not Found : 请求资源不存在,eg,输入错误的URL 500 Internal Server Error : 服务器发生了不可预期的错误 503 Server Unavailable : 服务器当前不能处理客户端的请求，一段时间后可能恢复正常GET请求和POST请求的区别 Http报文层面：GET将信息放在URL，POST放在报文体中 数据库层面：GET符合幂等性和安全性，POST不符合 （幂等性：对数据库多次操作获得结果是一样的。安全性：没有改变数据库中的数据） 其他层面：GET可以被缓存、被储存，而POST不行 Cookie和Session的区别Cookie简介 由服务器发给客户端的特殊信息，以文本的形式存放在客户端 客户端再次请求的时候，会把Cookie回发 服务器接收到后，会解析Cookie生成与客户端相对应的内容 Cookie 的设置以及发送过程 客户端发送HTTP Request 到服务端 服务端发送HTTP Response + Set-Cookie 客户端发送HTTP Request + Cookie 服务器发送HTTP Response Session 简介 服务器端的机制，在服务器上保存的信息 解析客户端请求并操作session id,按需保存状态信息 Session的实现方式方式 使用Cookie来实现 服务器给每个session分配一个JSESSIONID,并通过Cookie发送给客户端，当客户端发起新的请求的时候，将在Cookie头中携带这个JSESSIONID，这样服务器能够找到客户端对应的session 使用URL回写来实现 URL回写指服务器在发送给浏览器页面的所有链接中都携带JSSESSIONID的参数，点击任何一个链接都会把JSESSIONID带回服务器。 Tomcat对session的实现一开始同时实现的，使用Cookie和URL回写机制，如果发现客户端支持cookie,就继续使用cookie停止使用URL回写，如果发现Cookie被禁用，就一直使用URL回写 Cookie和Session的区别 Cookie数据存放在客户的浏览器上，Session数据放在服务器上 Session相对Cookie更安全 若考虑减轻服务器负担，应当使用Cookie]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的滑动窗口]]></title>
    <url>%2F2019%2F10%2F06%2FTCP%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[RTT和RTO RTT:发送一个数据包到接受对应ACK所花费的时间 RTO:重传时间间隔；RTT是根据RTO计算出来的 我们要实现对数据的批量发送，TCP要解决可靠传输和包乱序的问题，所以TCP需要知道网络实际的数据处理带宽或是数据处理速度才不会引起网络拥塞导致丢包 TCP使用滑动窗口做流量控制与乱序重排 保证TCP可靠性 保证TCP的流控特性。（流量控制：window，用于接收方通知发送方自己还有多少缓冲区可以接受数据，发送方根据接收方的处理能力发送数据，不会导致接受不过来） TCP的传输可靠性来源于确认重传机制，TCP的滑动窗口可靠性也是建立在确认重传基础上。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>RTT</tag>
        <tag>RTO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP的区别]]></title>
    <url>%2F2019%2F10%2F06%2FTCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[UDP简介 面向非连接 不维护连接状态，支持同时向多个客户端传输相同消息 数据包报头只有8个字节，额外开销较小 吞吐量只受限于数据生成速率，传输速率及机器性能 尽最大努力交付，不保证可靠交付，不需要维护复杂链接状态表 面向报文，不对应用程序提交的报文信息进行拆分或合并 TCP和UDP的区别 面向连接 VS 无连接 可靠性 有序性 速度 量级]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信点餐系统-service层设计]]></title>
    <url>%2F2019%2F09%2F20%2F%E5%BE%AE%E4%BF%A1%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F-service%E5%B1%82%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[常用注解@Entity 表明该类为一个实体类,类名和表明要一致。@Table 当实体类映射的数据表名不同名时使用，与@Entity并列使用 @Table(name=”XXXXX”)。@DynamicUpdate 自动更新updateTime@Data 自动生成getter和setter方法以及构造方法@Transational 在测试方法中使用测试完自动回滚，数据不保存数据库 如何自动生成getter/setter,toString的方法、1.引入lombok依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; 2.安装lombok插件3.使用注解@Data 如何根据categoryType 查询返回List 对象方法命名规则： 123List&lt;ProductCategory&gt; findByCategoryTypeIn(List&lt;Integer&gt; list)List&lt;Integer&gt; list = Arrays.asList(1,2,3,4);repository.findByCategoryTypeIn(list); JAVA8特性把List里的属性封装进另一个List 1List&lt;Integer&gt; categoryTypeList = productInfoList.strem().map(e -&gt; e.getCategoryType()).collect(Collectors.toList()) VO ViewObject 返回给前端的对象1.应根据前端需要的字段重新定义一个 VO，不要有多余字段2.VO字段应该和对象的字段名称保持一致，方便Copy属性3.@JsonProperty 注解的使用， 123//返回给前台的JSON字段 转成自定义的名称@JsonProperty(&quot;id&quot;)private String productId 写代码中的注意事项1.不要在 for循环里有查询2.不要在代码里直接写数字，应该使用枚举]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVA框架-Spring]]></title>
    <url>%2F2019%2F09%2F19%2FJAVA%E6%A1%86%E6%9E%B6-Spring%2F</url>
    <content type="text"></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IOC</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信点餐系统-日志框架]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%BE%AE%E4%BF%A1%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[使用的日志框架日志门面：SLF4J日志实现：Logback 使用slf4j 打印日志的两种方式1.手动初始化Log4j的一个实例 12Logger logger = LoggerFactory.getLogger(this.class)logger.info(&quot;info...&quot;); 2.使用注解 @Slf4j ,可以直接使用log添加依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 1log.info(&quot;info...&quot;); 使用占位符可直接打印变量123String name = &quot;root&quot;;String password = &quot;123455&quot;;log.info(&quot;name: &#123;&#125;, password: &#123;&#125;&quot; , name,password) Logback配置1.创建 logback-spring.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;configuration&gt; &lt;appender name=&quot;consoleLog&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;pattern&gt; %d - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=&quot;fileInfoLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;!--滚动策略,每天一个日志--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--路径--&gt; &lt;fileNamePattern&gt; F:\log\tomcat\info.%d.log &lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;appender name=&quot;fileErrorLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;!--滚动策略--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--路径--&gt; &lt;fileNamePattern&gt; F:\log\tomcat\error.%d.log &lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;consoleLog&quot;/&gt; &lt;appender-ref ref=&quot;fileInfoLog&quot;/&gt; &lt;appender-ref ref=&quot;fileErrorLog&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>springboot实战</category>
      </categories>
      <tags>
        <tag>日志框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信点餐系统-数据库设计]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%BE%AE%E4%BF%A1%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[数据库设计表的的构成类目表，商品表，订单主表，订单详情表 日期时间类型设置默认时间，DEFAULT CURRENT_TIMESTAMP时间类型字段自动更新数据，ON UPDATE CURRENT_TIMESTAMP SQL UNIQUE 约束UNIQUE约束唯一标识数据库表中的每条记录。UNIQUE和PRIMARY KEY 约束均为列或列激活提供了唯一性的保证。PRIMARY KEY 拥有自动定义的 UNIQUE约束。请注意，每个表可以有多个UNIQUE约束，但是每个表只能有一个 PRIMARY KEY 约束。 数据库编码使用 UTF-8 unicode(uftf8mb4)可以存表情]]></content>
      <categories>
        <category>springboot实战</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的三次握手]]></title>
    <url>%2F2019%2F05%2F22%2FTCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%2F</url>
    <content type="text"><![CDATA[TCP的三次握手]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP的三次握手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础知识]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[OSI开放式互联参考模型 物理层： 定义物理设备标准（网线类型、光纤接口类型、各种传输介质的传输速率）,主要作用：传输比特流0101二进制数据 —&gt; 转化为电流强弱 —&gt; 0101 数模转换和模数转换 单位:比特 （网卡） 数据链路层： 定义了如何格式化数据以进行传输，和控制对物理介质的访问。主要作用：提供错误检测和纠正，确保数据传输可靠性。该层将比特数据组成为帧。（交换机） 网络层： 将网络地址翻译成对应的物理地址，决定数据从发送方路由到接收方，单位是数据包。有IP协议）路由器 传输层： 解决主机间的数据传输。（传输协议，流量控制，接收方接收数据快慢程度，规定发送速率；还可以分割大的数据包；TCP和UDP协议） 会话层： 定义不同机器上的用户之间建立及管理回话，解决应用程序之间的通信，自动收发包和寻址的功能 表示层： 解决不同操作系统之间的通信语法问题。信息的语法语义，加密解密，转换翻译 应用层： 规定接收方发送方必须使用一个固定长度的消息头，消息头必须使用固定的组成继续消息体的长度，关注TCP/IP协议中的http协议 OSI 参考模型并不是一个标准，概念性框架。事实的标准是 TCP/IP 四层架构参考模型 OSI的“实现” TCP/IP协议 TCP/IP四层模型（从下到上）：链路层：获取以太网首部网络层：获取IP首部传输层：获取TCP首部应用层：HTTP数据]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>OSI七层模型</tag>
      </tags>
  </entry>
</search>
