{"meta":{"title":"Contunued Story","subtitle":null,"description":"Like a bird in the sky","author":"zero","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2019-04-22T06:35:58.000Z","updated":"2019-10-12T14:07:18.670Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"有一个夜晚我烧毁了所有的记忆 从此我的梦就透明了 有一个早晨我扔掉了所有的昨天 从此我的脚步就轻盈了"},{"title":"分类","date":"2019-04-22T06:35:02.000Z","updated":"2019-10-11T03:35:44.717Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-22T06:35:49.000Z","updated":"2019-10-11T03:35:08.726Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"谈谈ClassLoader","slug":"谈谈ClassLoader","date":"2019-10-26T03:40:31.000Z","updated":"2019-10-30T05:58:23.913Z","comments":true,"path":"2019/10/26/谈谈ClassLoader/","link":"","permalink":"http://yoursite.com/2019/10/26/谈谈ClassLoader/","excerpt":"","text":"类从编译到执行的过程 编译器将Robot.java源文件编译为Robot.class字节码文件 ClassLoader将字节码转化为jvm中的Class对象 JVM利用Class对象实例化为Robot对象 谈谈ClassLoaderClassLoader 的种类 BootStrapClassLoader:C++编写，加载核心库 java.* ExtClassLoader:Java编写，加载扩展库javaa.* AppClassLoader:Java编写，加载程序所在目录 自定义ClassLoader:Java编写，定制化加载 ClassLoader的作用在Java中有些非常重要的作用，ClassLoader主要工作在Class装载的加载阶段，主要作用是从系统外部获得Class二进制数据流。它是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接，初始化工作 ClassLoader双亲委派机制 自底而上检查类是否已经加载Custom ClassLoader–App ClassLoader–Extension ClassLoader–BootStrap ClassLoader 自上而下尝试加载类BootStrap:加载 jre\\lib\\rt.jar 或者 Xbootclasspath选项指定的jar包Extension:加载 jre\\lib\\ext*.jar 或者 Djava.ext.dirs指定目录下的jar包App: 加载ClassPath 或者 Djava.class.path所指定的目录下的类和jar包 为什么使用双亲委派机制 避免多份同样字节码的加载 类的装载过程 加载：通过ClassLoader加载class文件字节码生成Class对象 链接： 校验：检查加载的class的正确性和安全性 准备：为类变量分配存储空间并设置类变量初始值 解析：JVM将常量池内的符号引用转换为直接引用 初始化：执行类变量赋值和静态代码块loadClass和forName的区别Class.forName是类加载到初始化的步骤Classloader.loadClass是刚执行完加载class Class.forName已完成初始化，那为什么还要用LoadClass呢？LoadClass在springIOC中资源加载器获取要读入的资源的时候，即读取一些bean的配置文件的时候，如果是以classPath方式来加载的话 就需要使用Classload.loadClass来加载，之所以这样做是和springIOC的lazy-loading（懒加载）有关，springIOC为了加快初始化速度因此大量使用延迟加载技术而使用ClassLoad不需要执行类中的初始化代码（static）步骤和连接步骤，这样子做可以加快加载速度 ，把类的初始化工作留到实际使用到这个类的时候才去做.","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"ClassLoader","slug":"ClassLoader","permalink":"http://yoursite.com/tags/ClassLoader/"},{"name":"类的装载","slug":"类的装载","permalink":"http://yoursite.com/tags/类的装载/"}]},{"title":"JVM如何加载class文件","slug":"JVM如何加载class文件","date":"2019-10-26T01:53:49.000Z","updated":"2019-10-26T03:29:53.900Z","comments":true,"path":"2019/10/26/JVM如何加载class文件/","link":"","permalink":"http://yoursite.com/2019/10/26/JVM如何加载class文件/","excerpt":"","text":"Java虚拟机Java虚拟机：抽象化的计算机，通过在实际的计算机上个仿真模拟计算机功能来实现的，有自己完善的硬件架构：处理器，堆栈，寄存器等，还具有相应的指令系统，jvm 屏蔽了与具体操作系统平台相关的信息，使得java程序只需要生成在java虚拟机上运行的字节码，就可以在不同平台上不加修改的运行。其中最重要的两点：JVM内存结构模型，GC jvm是内存中的虚拟机，jvm的存储就是内存，所有写的 类，常量，变量，方法都在内存中这决定着程序的健壮和高效 Class Loader ： 依据特定格式，加载class文件到内存 Runtime Data Area ：JVM内存空间结构模型 Native Interface: 融合不同开发语言的原生库为Java所用 Execution Engine ：对命令进行解析 JVM结构： Class Loader, Runtime Data Area, Execution Engine, Native Interface Java反射机制JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 写一个反射的例子Robot.java 1234567891011package com.interview.javabasic.reflectpublic class Robot&#123; private String name; public void sayHi(String helloSentence)&#123; System.out.println(helloSentence + &quot;&quot; + name) &#125; private String throwHello(String tag)&#123; return &quot;Hello&quot; + tag; &#125;&#125; ReflectSample.java 1234567891011121314151617181920public static void main(String[] args)&#123; //先获取Robot类，需要全路径 Class rc = Class.forNam(&quot;com.interview.javabasic.reflect.Robot&quot;) //创建实例,需要强转，newInstance返回的是泛型 Robot r = (Robot)rc.newInstance(); System.out.println(&quot;Class name is &quot; + rc.getName()); //通过反射获取私有方法,throwHello接收一个String类型的参数 Method getHello = rc.getDeclaredMethod( name: &quot;throwHello&quot;,String.class)； getHello.setAccessible(true); //需要传入对象实例，和方法参数 Object str = getHello.invoke(r,&quot;Bob&quot;); System.out.println(&quot;getHello result is &quot; + str); //第二种获取方法获取方法 Method sayHi = rc.getMethod( name: &quot;sayHi&quot;,String.class)； sayHi.invoke(r,&quot;Welcome&quot;); //获取私有类型的Filed Filed name = rc.getDeclaredField(name: &quot;name&quot;); name.setAccessible(true); name.set(r,&quot;Alice&quot;)&#125; Metohd:newInstance()方法返回的是泛型。getDeclaredMethod可以获得该类所有的方法，除去继承和实现了接口的方法。如果是私有的方法，必须使用setAccessible(true)方法。getMethod可以获得该类所有的公有方法，还有所继承的以及实现了接口的方法。 Field:getDeclaredField获取属性如果是私有属性也要设置setAccessible(true)","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"JVM内存结构模型","slug":"JVM内存结构模型","permalink":"http://yoursite.com/tags/JVM内存结构模型/"},{"name":"反射","slug":"反射","permalink":"http://yoursite.com/tags/反射/"}]},{"title":"谈谈我对Java的理解","slug":"谈谈我对Java的理解","date":"2019-10-25T08:23:12.000Z","updated":"2019-10-26T01:52:47.696Z","comments":true,"path":"2019/10/25/谈谈我对Java的理解/","link":"","permalink":"http://yoursite.com/2019/10/25/谈谈我对Java的理解/","excerpt":"","text":"谈谈我对Java的理解从以下几个点进行扩展 平台无关性：一次编译到处运行GC垃圾回收：不用手动释放内存语言特性：泛型、lamda、反射面向对象：封装、继承、多态类库：自带的集合和并发库异常处理 Compile Once,Run Anywhere如何实现（如何实现平台无关的）？编译时：javac运行时:java.java文件首先经过javac编译生成字节码。将字节码保存在.class文件中。.class文件是跨平台的基础。再由不同平台的JVM进行解析，java语言在不同的平台上运行时不需要进行重新编译，java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令。 为什么jvm不直接将字节码解析成机器码才去执行 每次执行都需要各种检查（语法，句法，语义的检查，每次执行的时候，这些语义分析结果不会被保留下来。因此引入字节码，在每次执行程序是不需要各种校验和补全的） 兼容性，可以将别的语言（groovy,scala）解析成字节码","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"Java特性","slug":"Java特性","permalink":"http://yoursite.com/tags/Java特性/"},{"name":"平台无关性","slug":"平台无关性","permalink":"http://yoursite.com/tags/平台无关性/"}]},{"title":"Linux体系结构","slug":"Linux体系结构","date":"2019-10-21T14:29:34.000Z","updated":"2019-10-25T07:31:47.443Z","comments":true,"path":"2019/10/21/Linux体系结构/","link":"","permalink":"http://yoursite.com/2019/10/21/Linux体系结构/","excerpt":"","text":"Linux 体系结构 体系结构主要分为用户态（用户上层活动）和内核态 内核：本质是一段管理计算机硬件设备的程序 系统调用：内核的访问接口，是一种不能再简化的操作 公用函数库：系统调用的组合拳 Shell：命令解释器，可编程 远程登录终端利用ssh登录远程服务器 安装ssh： 1yum install ssh 启动ssh： 1service sshd start 登录远程服务器： 123ssh -p 50022 my@127.0.0.1输入密码：my@127.0.0.1: -p 后面是端口 my 是服务器用户名 127.0.0.1 是服务器 ip 回车输入密码即可登录 如何查找特定的文件find1语法：find path 【options】 params 作用：在指定目录下查找文件 常用的方式~表示当前用户的目录 1234 find ~ -name &quot;target1.java&quot; :查找精确文件 find ~ -name &quot;target*&quot; :查找精确文件 find ~ -iname &quot;target*&quot; :不区分文件名大小写去查找文件 man find : 更多关于find指令的使用说明 检索文件内容1语法：grep 【options】 pattern file 全称：Global Regular Expression Print作用：在指定目录下查找文件 12例如：查找包含内容&quot;moo&quot; 以target开头的文件grep &quot;moo&quot; target* 管道操作符|可将指令连接起来，前一个指令的输出作为后一个指令的输入 12例如：查找当前用户下以target开头的文件find ~ | grep &quot;target*&quot; 常用的方式123456781.在内容（文件）里面查找包含某字段的文件，并展示出对应行内容grep &apos;partial\\[true\\]&apos; bac-plat-al-data.info.log 2.-o 筛选出符合正则表达式的内容grep -o &apos;engine\\[[0-9a-z]*\\]&apos; 3.-v 过滤掉包含相关字符串的内容grep -v &apos;grep&apos; 对文件内容做统计场景：我想筛选出 partial为true的引擎，并统计日志里出现的次数。当我们发现某个检索引擎的partial为true超过一定次数后，说明该引擎需要从集群中摘掉进行修复； awk1语法：awk [options] &apos;cmd&apos; file 一次读取一行文本，按输入分隔符进行切片，切成多个组成部分 将切片直接保存在内建的变量中，$1,$2,..($0表示行的全部) 支持对单个切片的判断，支持循环判断，默认分隔符为空格 常用的方式12345678打印出第一列和第四列的内容：awk &apos;&#123;print $1,$4&#125;&apos; 文件名筛选出列指定字符的行：awk &apos;$1==&quot;tcp&quot; &amp;&amp; $2==1&#123;print $0&#125;&apos; 文件名打印出表头：awk &apos;($1==&quot;tcp&quot; &amp;&amp; $2==1) || NR==1 &#123;print $0&#125;&apos; 文件名以指定分隔符分割内容：awk -F &quot;,&quot; &apos;&#123;print $2&#125;&apos; 文件名 12Linux 命令 awk 统计：awk &apos;&#123;enginearr[$1]++&#125;END&#123;for (i in enginearr) print i &quot;\\t&quot; enginearr[i]&#125;&apos; enginearr ：自定义的数组，如果第一列$1出现重复就自增1END ：扫描统计结束{for(i in enginearr)}：循环自定义的数组，定义变量 iprint i : 打印 i“\\t” 拼接回车符enginearr[i] : 指定自定义数组 批量替换文本内容sed1语法：sed [option] &apos;sed command&apos; filenae 全名stream editor,流编辑器适合用于对文本的行内容进行处理 常用的方式12345678910111213141.将文件中以Str开头的字符串替换成 String：sed -i &apos;s/^Str/String/&apos; replace.txt2.将末尾的点号转为分号：sed -i &apos;s/\\.$/\\;/&apos; replace.txt3.将所有的&quot;Jack&quot;替换成&quot;me&quot;sed -i &apos;s/Jack/me/g&apos; replace.txt4.删除空行命令sed -i &apos;/^ *$/d&apos; replace.txt5.删除包含特定字符的行：sed -i &apos;/Integer/d&apos; replace.txt 特别指出： 指令中加入 -i 表示修改保存到文件中 替换语法后加入 /g 表示将文件中所有符合条件的内容全部替换，否则只替换一行中第一次匹配到的字符 总结：经常用到的Shell命令 find grep 管道操作符| awk sed","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"Redis集群","slug":"Redis集群","date":"2019-10-21T14:27:28.000Z","updated":"2019-10-21T14:27:28.170Z","comments":true,"path":"2019/10/21/Redis集群/","link":"","permalink":"http://yoursite.com/2019/10/21/Redis集群/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Pipeline及主从同步","slug":"Pipeline及主从同步","date":"2019-10-21T14:27:10.000Z","updated":"2019-10-21T14:27:10.138Z","comments":true,"path":"2019/10/21/Pipeline及主从同步/","link":"","permalink":"http://yoursite.com/2019/10/21/Pipeline及主从同步/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Redis持久化方式","slug":"Redis持久化方式","date":"2019-10-21T14:23:15.000Z","updated":"2019-10-21T14:25:32.283Z","comments":true,"path":"2019/10/21/Redis持久化方式/","link":"","permalink":"http://yoursite.com/2019/10/21/Redis持久化方式/","excerpt":"","text":"RDB(快照)持久化：保存某个时间点的全量数据快照","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"RDB","slug":"RDB","permalink":"http://yoursite.com/tags/RDB/"},{"name":"AOF","slug":"AOF","permalink":"http://yoursite.com/tags/AOF/"}]},{"title":"如何实现异步队列","slug":"如何实现异步队列","date":"2019-10-20T06:55:22.000Z","updated":"2019-10-21T00:51:10.064Z","comments":true,"path":"2019/10/20/如何实现异步队列/","link":"","permalink":"http://yoursite.com/2019/10/20/如何实现异步队列/","excerpt":"","text":"用list作为队列rpush 作为生产者生产消息， lpop 作为消费者消费消息缺点： 没有等待 队列里有值就直接消费弥补：可以通过在应用层引入sleep机制去调用lpop重试； 如果不用 sleep机制 ，可以使用 blpop key[key..] timeout 阻塞直到队列有消息或者超时缺点：一个生产者对应一个消费者 pub/sub 主题订阅模式发送者 pub 发送消息，订阅者 sub 接受消息订阅者可以订阅任意数量的频道缺点： 消息无状态，无法保证可达","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"异步队列","slug":"异步队列","permalink":"http://yoursite.com/tags/异步队列/"}]},{"title":"如何通过Redis实现分布式锁","slug":"如何实现分布式锁","date":"2019-10-18T05:47:11.000Z","updated":"2019-10-18T06:52:06.874Z","comments":true,"path":"2019/10/18/如何实现分布式锁/","link":"","permalink":"http://yoursite.com/2019/10/18/如何实现分布式锁/","excerpt":"","text":"什么是分布式锁分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁的实现 分布式锁需要解决的问题 互斥性：任意时刻只能有一个客户端获取到锁 安全性：锁只能被持有该锁的客户端删除 死锁：获取锁的客户端因为某些原因宕机而未能释放锁，其他客户端再也无法获取到该锁而导致的死锁 容错：当部分Redis节点宕机了之后客户端仍然能够获取锁和释放锁SENTNX key value:如果key不存在，则创建并赋值 时间复杂度 O(1) 返回值：设置成功，返回1；设置失败，返回0 1234get locknx(nil)setnx locknx test(integer)1 setnx 操作是原子性的，初期被用来实现分布式锁；在执行某段代码逻辑的时候先尝试使用setnx对某个key设值，如果设置成功则证明此时没有别的线程在执行该段代码（占用该独占资源），这个时候线程就可以顺利的执行该段代码逻辑，如果设置失败则证明有别的程序或线程占用该资源。当前线程需要等待直至setnx成功 如何解决SETNX长期有效的问题EXPIRE key seconds 设置key的生存时间，当key过期时（生存时间为0），会被自动删除 缺点：原子性得不到满足 12//设置过期时间2秒钟expire locknx 2 伪代码示例： 12345678RedisService redisService = SpringUtils.getBean(RedisService.class)long status = redisService.setnx(key,&quot;1&quot;)if(status == 1)&#123; redisService.expire(key,expire); //执行独占资源逻辑 doOcuppiedWord()&#125; 潜在问题，在setnx后线程挂掉，key将会被一直占用 SET key value [EX seconds][PX milliseconds][NX|XX]ex:设置键的过期时间为单位妙px:设置键的过期时间为单位毫秒NX:只在键不存在时，才对键进行设置操作XX:只在键已经存在时，才对键进行设置操作设置成功返回ok,否则返回nil 1set locktarget 12345 ex 10 nx 大量的key同时过期的注意事项集中过期，由于清除大量的key很耗时，会出现短暂的卡顿现象解决方案：在设置key的过期时间的时候，给每个key加上随机值","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"分布式锁","slug":"分布式锁","permalink":"http://yoursite.com/tags/分布式锁/"}]},{"title":"Redis简介","slug":"Redis简介","date":"2019-10-16T13:13:26.000Z","updated":"2019-10-18T05:54:55.909Z","comments":true,"path":"2019/10/16/Redis简介/","link":"","permalink":"http://yoursite.com/2019/10/16/Redis简介/","excerpt":"","text":"缓存中间件——Memcache和Redis的区别Mecache：代码层次类似Hash 支持简单数据类型 不支持数据持久化存储 不支持主从 不支持分片Redis 数据类型丰富 支持数据磁盘持久化存储 支持主从 支持分片 为什么Redis能这么快100000+QPS(QPS既query per second 每秒内查询次数) 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高 数据结构简单，对数据操作也简单 采用单线程，单线程也能处理高并发请求，想多核也可启动多实例 使用多路I/O 复用模型，非阻塞IO redis 是跑在单线程中的，所有的操作又是按照线性顺序执行的，但是由于读写操作等待用户输入或者输出都是阻塞的，所以io操作在一般情况下往往不能直接返回，这会导致某一文件的io阻塞，进而导致整个进程无法对其他客户端提供服务而io多路复用就是为了解决这个问题的 多路I/O复用模型FD：File Descriptor,文件描述符一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射 Redis采用的I/O多路复用函数：epoll/kqueue/evport/select? 因地制宜 优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现 以时间复杂度为O(n)的select作为保底 基于react设计模式监听I/O事件 Redis常用的数据类型 String:最基本的数据类型，二进制安全 Hash:String 元素组成的字典，适合用于存储对象 List:列表，按照String元素插入顺序排序 Set:String元素组成的无序集合，通过哈希表实现，不允许重复 Sorted-Set:通过分数来为集合中的成员进行从小到大的排序 用于计数的HyperLogLog ,用于支持存储地理信息位置的Geo 从海量数据查询某一固定的前缀key使用keys对线上的业务的影响KEYS pattern：查找所有符合给定模式pattern的key KEYS指令一次性返回所有匹配的key 键的数量过大会使服务器卡顿 KEYS CURSOR [MATCH pattern][COUNT count] 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程 以0作为游标开始一次新的迭代，知道命令返回游标0完成一次游历 不保证每次执行都返回某个给定数量的元素，支持模糊查询 一次返回的数量不可控，只能是大概率符合count参数 12//开始迭代返回以k1开始的key,希望一次返回10个scan 0 match k1* count 10","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"多路I/O复用模型","slug":"多路I-O复用模型","permalink":"http://yoursite.com/tags/多路I-O复用模型/"}]},{"title":"数据库关键语法","slug":"数据库关键语法","date":"2019-10-16T08:29:26.000Z","updated":"2019-10-16T13:09:10.429Z","comments":true,"path":"2019/10/16/数据库关键语法/","link":"","permalink":"http://yoursite.com/2019/10/16/数据库关键语法/","excerpt":"","text":"关键语法 GROUP BY HAVING 统计相关：COUNT,SUM,MAX,MIN,AVG GROUP BY 满足 SELECT子句中列名必须为分组列或者列函数 列函数对于group by子句定义的每个组各返回一个结果 HAVING 通常与GRPUP BY子句一起使用 WHERE过滤行，HAVING过滤组 出现在同一sql的顺序：WHERE&gt;GROUP BY&gt;HAVING","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"InnoDB可重复读隔离级别下如何避免幻读","slug":"InnoDB可重复读隔离级别下如何避免幻读","date":"2019-10-16T07:15:06.000Z","updated":"2019-10-16T08:15:50.399Z","comments":true,"path":"2019/10/16/InnoDB可重复读隔离级别下如何避免幻读/","link":"","permalink":"http://yoursite.com/2019/10/16/InnoDB可重复读隔离级别下如何避免幻读/","excerpt":"","text":"InnoDB可重复读隔离级别下如何避免幻读表象：快照读（非堵塞读） –伪MVCC内在：next-key锁（行锁+gap锁） next-key锁（行锁+gap锁） 行锁 Gap锁 Gap锁Gap的定义：索引字段排序结果的左开右闭区间，例如：1，3，5，7 的Gap为（-∞,1] (1,3] (2,7] (7,+∞]Gap锁的触发条件：使用主键/唯一索引的当前读: where条件精确每一行，只触发行锁 命中部分行，不命中任何一行，触发Gap锁 使用非唯一索引的当前读: 触发Gap锁 不使用索引： 触发Gap锁，并且锁定所有的Gap，相当于锁表","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[]},{"title":"锁模块之当前读和快照读","slug":"锁模块之当前读和快照读","date":"2019-10-16T06:37:29.000Z","updated":"2019-10-16T07:12:33.216Z","comments":true,"path":"2019/10/16/锁模块之当前读和快照读/","link":"","permalink":"http://yoursite.com/2019/10/16/锁模块之当前读和快照读/","excerpt":"","text":"当前读和快照读 当前读：就是加了锁的增删改查语句。读取的是记录的最新版本。读取的时候保证其他事务不能对数据进行修改。 12select ... lock in share mode ,select ... for update update,delete,insert 快照读：不加锁的非阻塞读 ，select RC、RR级别下的InnoDB的非堵塞读（快照读）如何实现 数据行里的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段 DB_TRX_ID：事务ID，标识对本行数据最近一次的更新(增删改) DB_ROLL_PTR：回滚指针， 指向回滚日志undo log的一条记录，一次更新对应一条undo log记录 DB_ROW_ID：新行插入，产生一个自增ID undo日志undo log：回滚日志，存储各个老版本的数据，由undo链串起来 含insert undo log和 update undo log read view：决定当前数据看到的是哪个版本。用来做可见性判断,即我们做快照读select的时候，会针对我们查询的数据，创建出一个read view来决定当前事务能看到那个版本的数据，可能当前最新，也可能是undo log 中某个版本的数据。它遵循一个可见性算法，主要是将要修该的数据的DB_TRX_ID取出来与系统其他活跃事务id作对比，如果大于或等于就通过DB_ROLL_PTR指针取出undo log 上一层的的DB_TRX_ID直到小于这些活跃事务为止。这样保证了我们获取的数据版本是当前可见的最稳定版本。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"锁模块","slug":"锁模块","permalink":"http://yoursite.com/tags/锁模块/"},{"name":"当前读","slug":"当前读","permalink":"http://yoursite.com/tags/当前读/"},{"name":"快照读","slug":"快照读","permalink":"http://yoursite.com/tags/快照读/"}]},{"title":"锁模块之数据事务","slug":"锁模块之数据事务","date":"2019-10-12T08:25:36.000Z","updated":"2019-10-15T03:21:42.228Z","comments":true,"path":"2019/10/12/锁模块之数据事务/","link":"","permalink":"http://yoursite.com/2019/10/12/锁模块之数据事务/","excerpt":"","text":"数据库事务的四大特性ACID 原子性(Athomic) : 事务包含的全部操作要么全部执行，要么全部失败回滚 一致(Consistency) : 事务应确保数据库的状态从一个一致状态到另一个一致状态(eg:转账问题，A和B一共2000，无论来回怎么转总和还是2000) 隔离性(Isolaton) 持久性(Durability)：一个事务的提交代表了它对数据库的修改永久保存在数据库中，当系统发生故障时确保已提交事务的更新不能丢失，确保已提交事务的更新能恢复 事务隔离级别以及各级别下的并发访问问题事务隔离级别和各个级别的并发访问问题。更新丢失（MySQL所有事务隔离级别在数据库层面上均可避免）事务A对数据进行操作时，事务B也在对同一数据更新操作并完成了提交，然后事务A遇到异常进行回滚导致事务B的更新丢失。 脏读一个事务读到另一个事务未提交的数据。 不可重复读事务A在多次读取同一数据的过程中，事务B对数据进行更新并提交，导致事务A多次读取同一数据时结果不一致。 幻读事务A读取若干行数据，事务B以插入或删除行的方式来修改事务A的结果集。 其中不可重复读与幻读比较相似，不可重复读侧重对同一数据的修改，幻读侧插入增或删除数据。事务隔离级别越高，对性能的影响也越大。 事务并发访问引起的问题以及如何避免 更新丢失——mysql所有事务隔离级别在数据库层面上均可避免 脏读——READ-COMMITTED事务隔离级别以上避免 不可重复读——REPEATABLE-READ事务隔离级别以上可避免 幻读——SERIALIZABLE事务隔离级别避免 事务隔离级别 更新丢失 脏读 不可重复度 幻读 未提交读 避免 发生 发生 发生 已提交读 避免 避免 发生 发生 可重复读 避免 避免 避免 发生 串行化 避免 避免 避免 避免 InnoDB可重复度隔离级别下如何避免幻读","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"锁模块","slug":"锁模块","permalink":"http://yoursite.com/tags/锁模块/"},{"name":"数据库事务","slug":"数据库事务","permalink":"http://yoursite.com/tags/数据库事务/"},{"name":"ACID","slug":"ACID","permalink":"http://yoursite.com/tags/ACID/"}]},{"title":"索引额外问题之如何调优sql","slug":"索引额外问题之如何调优sql","date":"2019-10-11T06:37:24.000Z","updated":"2019-10-11T10:40:54.791Z","comments":true,"path":"2019/10/11/索引额外问题之如何调优sql/","link":"","permalink":"http://yoursite.com/2019/10/11/索引额外问题之如何调优sql/","excerpt":"","text":"常见问题总结 如何定位并优化慢查询sql 联合索引的最左匹配原则的成因 索引建立的越多越好吗如何定位并优化慢sql大致思路 根据慢日志定位慢sql 12345SHOW VARIABLES LIKE &apos;%quer%&apos;; 查看慢查询是否打开set global slow_query_log =on; 打开慢查询:set global long_query_time=1; 设置慢查询最大时间超过一秒就记录为慢查询 SHOW STATUS LIKE &apos;%slow_queries%&apos;; 查看慢sql条数sudo vim /usr/local/mysql/data/VM_33_68_centos-slow.log; 查看被记录到慢日志里面的日志 使用explain等工具分析sql explain字段 type ： mysql找到数据行的方式index 和 all 是全表扫描 extra：有很多值 Using filesort ，Using temporary 最常的慢的， 修改sql或者尽量让sql走索引 具体走那个索引是mysql查询优化器决定， 要强制制定走某个索引 要加上 force index（primary/其他） 联合索引的最左匹配原则 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配知道遇到范围查询（&gt; , &lt; , between, like ）就停止匹配，比如a=3and b = 4 and c &gt; 5 and d =6 如果建立（a，b，c，d）顺序的索引，d是用不到索引的，如果建立（a，b，d，c）的索引则可以用到，a、b、d的顺序可以任意调整 =和in可以乱序，比如a=1 and b=2 and c=3建立（a,b,c）索引可以任意顺序，mysql查询优化器会帮你优化成索引可以识别的形式 索引是建立得越多越好吗 数据量小的表不需要建立索引，建立索引会增加额外的索引开销 数据变更需要维护索引，因此更多的索引意味着更多的维护成本 更多的索引也意味着更多的空间","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"sql调优","slug":"sql调优","permalink":"http://yoursite.com/tags/sql调优/"}]},{"title":"密集索引和稀疏索引","slug":"密集索引和稀疏索引","date":"2019-10-11T03:52:34.000Z","updated":"2019-10-11T06:38:27.671Z","comments":true,"path":"2019/10/11/密集索引和稀疏索引/","link":"","permalink":"http://yoursite.com/2019/10/11/密集索引和稀疏索引/","excerpt":"","text":"密集索引和稀疏索引的区别 密集索引文件中的每个搜索码值都对应一个索引值 稀疏索引文件只为索引码的某些值建立索引项 InnoDB 和 MyISAM InnoDB 采用密集索引+稀疏索引,主键索引可以直接找到叶子节点中的数据,辅助键索引需要先找到主键再通过主键B+树找到数据 ,即InnoDB数据和索引是存放在一个文件里的 MysISam 全部采用稀疏索引,根据主键和辅助键的索引都只能找到一个地址信息,要再根据这个地址信息去另外一个文件中寻找数据,即MysISam的索引和数据是分开存放的 表结构都存储在*.frm中MyISAM索引和数据是分开存储的.MYI存储索引.MYD存储数据InnoDB索引和数据是存在一起的.ibd","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"},{"name":"密集索引","slug":"密集索引","permalink":"http://yoursite.com/tags/密集索引/"},{"name":"稀疏索引","slug":"稀疏索引","permalink":"http://yoursite.com/tags/稀疏索引/"},{"name":"InnoDB","slug":"InnoDB","permalink":"http://yoursite.com/tags/InnoDB/"},{"name":"MyISAM","slug":"MyISAM","permalink":"http://yoursite.com/tags/MyISAM/"}]},{"title":"优化你的索引","slug":"优化你的索引","date":"2019-10-10T10:26:36.000Z","updated":"2019-10-11T06:39:33.192Z","comments":true,"path":"2019/10/10/优化你的索引/","link":"","permalink":"http://yoursite.com/2019/10/10/优化你的索引/","excerpt":"","text":"二叉查找树二叉树,(有明显缺陷的数据结构): 如果添加的数据一直在某一侧的时候,就会变成线性而二叉树,查询复杂度会上升,查找效率会大幅度降低 影响数据检索最根本的原因是IO,即数据库文件的读写，也就是将硬盘的数据读到内存中而我们的二叉树在检索深度每次加1后都需要读取一个节点,执行一次IO,效率很低 B-TreeB-TREEB树的定义： 根节点至少包含两个孩子 树中每个节点最多含有m个孩子（ m &gt;= 2） 除根节点和叶节点外，其他每个节点至少有 ceil(m/2)个孩子 所有叶子节点都位于同一层 假设每个非终端节点包含有n个关键字信息，其中 Ki(i=1,…n)为关键字，关键字按顺序排序K(i-1)&lt;Ki 关键字个数n必须满足 : [cell(m/2)-1]&lt;=n&lt;=m-1 非叶子节点的指针：P[1],p[2],….,p[M];其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1],K[i])的子树 B+-TreeB+树定义： 非叶子节点的子树指针和关键字个数相同 非叶子节点的子树指针P[i],指向关键字值[K[i],K[i+1])的子树, 大于等于 K[i] 小于 K[i+1] 非叶子节点仅用来做索引，数据都保存在叶子节点中 所有叶子节点均有一个链指针指向下一个叶子节点 B+Tree更适合用来存储索引 B+ 树的磁盘读写代价更低（程序运行，往往最耗时的操作就是IO，如果IO的次数越少，那么运行也就越快，代价也就越低，非叶子节点结构没有指向关键字对应表记录的指针，只存放索引，因此节点比B树更小） B+ 树的查询效率更加稳定，数据存放在叶节点中，也就意味着每次查询都需要经过从根节点到叶节点的查询路径，时间复杂度味为O(logn)，比较稳定 B+ 树更有利于对数据库的扫描（因为数据只存放在叶节点中，而且有顺序，所以更好的查询数据范围） Hash 索引 hash 命中key 直接定位数据，理论上高于 b-tree b+tree 只能用 = 和 in ，不能范围查询，不能排序，不能组合索引(比较hash值是否相等来查询数据,并不能代表hash值的实际大小) hash值命中同一个存放位置， 效率不稳定，有可能还不如b+ tree（想想线性二叉树）bitmap 索引bitmap位图，适用于字段值只是固定的几个，如男、女，颜色；便于高效统计。Oracle支持位图索引，数据结构了类似B+树。锁很严重，可能因为某行修改都会锁。适合并发较少，统计较多的情况","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"},{"name":"索引数据结构","slug":"索引数据结构","permalink":"http://yoursite.com/tags/索引数据结构/"}]},{"title":"数据库架构","slug":"数据库架构","date":"2019-10-08T14:24:35.000Z","updated":"2019-10-11T01:56:05.417Z","comments":true,"path":"2019/10/08/数据库架构/","link":"","permalink":"http://yoursite.com/2019/10/08/数据库架构/","excerpt":"","text":"如何去设计一个关系型数据库第一部分为存储部分，相当于文件系统，将数据持久化到存储设备中 第二部分为程序实例，对存储进行逻辑上的管理。 程序实例分为8个模块： 存储管理：将数据的逻辑关系转化为物理存储关系。 缓存机制：优化执行效率。 SQL解析：解析SQL语句。 日志管理：记录操作。 权限划分：进行多用户管理。 容灾机制：灾难恢复。 索引管理：优化数据查询效率。 锁管理：使数据库支持高并发。 常见问题 为什么要使用索引 什么样的信息能成为索引 索引的数据结构 密集索引和稀疏索引的区别 为什么要使用索引先说不使用索引情况下的全表扫描: 数据库存储的最小单位是块或者页,是由多行记录组成的。(一个表就是多个块或者多个页)我们把这些块或者页加载进来,然后对每个块或页进行轮训,找到目标返回,类似:要从一本字典的第一页开始查找数据,一页一页的查,如果数据量小还好,数据量大就很慢 所以我们推出索引的概念:也就是引入字典中目录的概念,我们可以通过字典的拼音,部首,进行一层又一层的有条理的查询而这些被另外定义出来的例如:拼音,部首,就可以叫做索引 简单讲就是:为了避免全表扫描,大幅提高查询数据的效率 什么样的信息能成为索引主键、唯一键、普通键 索引的数据结构 生成索引，建立二叉查找树进行二分查找 生成索引，建立B-Tree结构进行查找 生成索引，建立B+-Tree结构进行查找 生成索引，建立Hash结构进行查找","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"数据库架构","slug":"数据库架构","permalink":"http://yoursite.com/tags/数据库架构/"}]},{"title":"HTTP与HTTPS的区别","slug":"HTTP与HTTPS的区别","date":"2019-10-08T06:08:59.000Z","updated":"2019-10-10T13:39:57.381Z","comments":true,"path":"2019/10/08/HTTP与HTTPS的区别/","link":"","permalink":"http://yoursite.com/2019/10/08/HTTP与HTTPS的区别/","excerpt":"","text":"HTTPS 简介 HTTP HTTPS HTTP HTTP SSL OR TLS TCP TCP IP IP HTTPS:以计算机网络通信安全为目的的传输协议 SSL(Security Sockets Layer,安全套接层) 为网络通信提供安全及数据完整性一种安全协议 是操作系统对外API ,SSL3.0 后更名为TLS 采用身份验证和数据加密保证网络通信安全和数据完整性HTTP数据传输流程 浏览器将支持的加密算法发送给服务器 服务器选择一套浏览器支持的加密算法，以证书形式回发给浏览器 浏览器验证证书合法性，结合证书公钥加密信息发送给服务器 服务器使用私钥解密，验证哈希加密响应消息回发浏览器 浏览器解密响应消息，对消息进行验真，之后进行加密交换数据 区别 HTTPS需要到CA申请证书，HTTP不需要 HTTP超文本传输协议明文传输，HTTPS密文传输，HTTPS基于具有安全性的SSL加密 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口 HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"HTTP相关","slug":"HTTP相关","date":"2019-10-06T08:59:45.000Z","updated":"2019-10-08T01:44:06.285Z","comments":true,"path":"2019/10/06/HTTP相关/","link":"","permalink":"http://yoursite.com/2019/10/06/HTTP相关/","excerpt":"","text":"超文本传输协议HTTP主要特点 支持客户/服务器模式 简单快速 灵活 无连接 无状态 请求/响应的步骤 客户端连接到web服务器 发送HTTP请求 服务器接受请求并返回HTTP响应 释放连接TCP连接 客户端浏览器解析HTML内容 在浏览器地址键入URL，按下回车之后经历的流程 DNS解析 浏览器依据URL逐层查询DNS服务器缓存，解析URL中的域名所对应的的IP TCP连接 找到IP地址后根据IP和对应端口和服务器建立TCP连接，结合三次握手讲解 浏览器发送HTTP请求 服务器处理请求并返回HTTP响应报文 浏览器解析渲染页面 连接结束 结合四次挥手HTTP状态码五种可能的取值 1XX : 指示信息 – 表示请求已接收，继续处理 2XX : 成功–表示请求已被成功接收、理解、接受 3XX : 重定向 – 要完成请求必须进行更进一步的操作 4xx : 客户端错误 – 请求有语法错误或请求无法实现 5XX : 服务器端错误–服务器未能实现合法的请求常见状态码 200 OK : 正常返回信息 400 Bad Request : 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized : 请求未经授权，这个状态码必须和WWW-Authenticate 报头域一起使用 403 Forbidden : 服务器收到请求，但是拒绝提供服务 404 Not Found : 请求资源不存在,eg,输入错误的URL 500 Internal Server Error : 服务器发生了不可预期的错误 503 Server Unavailable : 服务器当前不能处理客户端的请求，一段时间后可能恢复正常GET请求和POST请求的区别 Http报文层面：GET将信息放在URL，POST放在报文体中 数据库层面：GET符合幂等性和安全性，POST不符合 （幂等性：对数据库多次操作获得结果是一样的。安全性：没有改变数据库中的数据） 其他层面：GET可以被缓存、被储存，而POST不行 Cookie和Session的区别Cookie简介 由服务器发给客户端的特殊信息，以文本的形式存放在客户端 客户端再次请求的时候，会把Cookie回发 服务器接收到后，会解析Cookie生成与客户端相对应的内容 Cookie 的设置以及发送过程 客户端发送HTTP Request 到服务端 服务端发送HTTP Response + Set-Cookie 客户端发送HTTP Request + Cookie 服务器发送HTTP Response Session 简介 服务器端的机制，在服务器上保存的信息 解析客户端请求并操作session id,按需保存状态信息 Session的实现方式方式 使用Cookie来实现 服务器给每个session分配一个JSESSIONID,并通过Cookie发送给客户端，当客户端发起新的请求的时候，将在Cookie头中携带这个JSESSIONID，这样服务器能够找到客户端对应的session 使用URL回写来实现 URL回写指服务器在发送给浏览器页面的所有链接中都携带JSSESSIONID的参数，点击任何一个链接都会把JSESSIONID带回服务器。 Tomcat对session的实现一开始同时实现的，使用Cookie和URL回写机制，如果发现客户端支持cookie,就继续使用cookie停止使用URL回写，如果发现Cookie被禁用，就一直使用URL回写 Cookie和Session的区别 Cookie数据存放在客户的浏览器上，Session数据放在服务器上 Session相对Cookie更安全 若考虑减轻服务器负担，应当使用Cookie","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/计算机网络/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"TCP的滑动窗口","slug":"TCP的滑动窗口","date":"2019-10-06T08:59:45.000Z","updated":"2019-10-06T14:13:09.044Z","comments":true,"path":"2019/10/06/TCP的滑动窗口/","link":"","permalink":"http://yoursite.com/2019/10/06/TCP的滑动窗口/","excerpt":"","text":"RTT和RTO RTT:发送一个数据包到接受对应ACK所花费的时间 RTO:重传时间间隔；RTT是根据RTO计算出来的 我们要实现对数据的批量发送，TCP要解决可靠传输和包乱序的问题，所以TCP需要知道网络实际的数据处理带宽或是数据处理速度才不会引起网络拥塞导致丢包 TCP使用滑动窗口做流量控制与乱序重排 保证TCP可靠性 保证TCP的流控特性。（流量控制：window，用于接收方通知发送方自己还有多少缓冲区可以接受数据，发送方根据接收方的处理能力发送数据，不会导致接受不过来） TCP的传输可靠性来源于确认重传机制，TCP的滑动窗口可靠性也是建立在确认重传基础上。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/计算机网络/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://yoursite.com/tags/滑动窗口/"},{"name":"RTT","slug":"RTT","permalink":"http://yoursite.com/tags/RTT/"},{"name":"RTO","slug":"RTO","permalink":"http://yoursite.com/tags/RTO/"}]},{"title":"TCP和UDP的区别","slug":"TCP和UDP的区别","date":"2019-10-06T08:55:45.000Z","updated":"2019-10-06T09:02:12.625Z","comments":true,"path":"2019/10/06/TCP和UDP的区别/","link":"","permalink":"http://yoursite.com/2019/10/06/TCP和UDP的区别/","excerpt":"","text":"UDP简介 面向非连接 不维护连接状态，支持同时向多个客户端传输相同消息 数据包报头只有8个字节，额外开销较小 吞吐量只受限于数据生成速率，传输速率及机器性能 尽最大努力交付，不保证可靠交付，不需要维护复杂链接状态表 面向报文，不对应用程序提交的报文信息进行拆分或合并 TCP和UDP的区别 面向连接 VS 无连接 可靠性 有序性 速度 量级","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/计算机网络/"}],"tags":[{"name":"UDP","slug":"UDP","permalink":"http://yoursite.com/tags/UDP/"}]},{"title":"微信点餐系统-service层设计","slug":"微信点餐系统-service层设计","date":"2019-09-20T05:40:03.000Z","updated":"2019-10-18T01:41:05.919Z","comments":true,"path":"2019/09/20/微信点餐系统-service层设计/","link":"","permalink":"http://yoursite.com/2019/09/20/微信点餐系统-service层设计/","excerpt":"","text":"常用注解@Entity 表明该类为一个实体类,类名和表明要一致。@Table 当实体类映射的数据表名不同名时使用，与@Entity并列使用 @Table(name=”XXXXX”)。@DynamicUpdate 自动更新updateTime@Data 自动生成getter和setter方法以及构造方法@Transational 在测试方法中使用测试完自动回滚，数据不保存数据库 如何自动生成getter/setter,toString的方法、1.引入lombok依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; 2.安装lombok插件3.使用注解@Data 如何根据categoryType 查询返回List 对象方法命名规则： 123List&lt;ProductCategory&gt; findByCategoryTypeIn(List&lt;Integer&gt; list)List&lt;Integer&gt; list = Arrays.asList(1,2,3,4);repository.findByCategoryTypeIn(list); JAVA8特性把List里的属性封装进另一个List 1List&lt;Integer&gt; categoryTypeList = productInfoList.strem().map(e -&gt; e.getCategoryType()).collect(Collectors.toList()) VO ViewObject 返回给前端的对象1.应根据前端需要的字段重新定义一个 VO，不要有多余字段2.VO字段应该和对象的字段名称保持一致，方便Copy属性3.@JsonProperty 注解的使用， 123//返回给前台的JSON字段 转成自定义的名称@JsonProperty(&quot;id&quot;)private String productId 写代码中的注意事项1.不要在 for循环里有查询2.不要在代码里直接写数字，应该使用枚举","categories":[{"name":"SpringBoot实战","slug":"SpringBoot实战","permalink":"http://yoursite.com/categories/SpringBoot实战/"}],"tags":[{"name":"lombok","slug":"lombok","permalink":"http://yoursite.com/tags/lombok/"}]},{"title":"JAVA框架-Spring","slug":"JAVA框架-Spring","date":"2019-09-19T03:40:36.000Z","updated":"2019-09-19T03:44:45.600Z","comments":true,"path":"2019/09/19/JAVA框架-Spring/","link":"","permalink":"http://yoursite.com/2019/09/19/JAVA框架-Spring/","excerpt":"","text":"","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"IOC","slug":"IOC","permalink":"http://yoursite.com/tags/IOC/"},{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"}]},{"title":"微信点餐系统-日志框架","slug":"微信点餐系统-日志框架","date":"2019-09-18T06:22:17.000Z","updated":"2019-10-18T01:40:28.182Z","comments":true,"path":"2019/09/18/微信点餐系统-日志框架/","link":"","permalink":"http://yoursite.com/2019/09/18/微信点餐系统-日志框架/","excerpt":"","text":"使用的日志框架日志门面：SLF4J日志实现：Logback 使用slf4j 打印日志的两种方式1.手动初始化Log4j的一个实例 12Logger logger = LoggerFactory.getLogger(this.class)logger.info(&quot;info...&quot;); 2.使用注解 @Slf4j ,可以直接使用log添加依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 1log.info(&quot;info...&quot;); 使用占位符可直接打印变量123String name = &quot;root&quot;;String password = &quot;123455&quot;;log.info(&quot;name: &#123;&#125;, password: &#123;&#125;&quot; , name,password) Logback配置1.创建 logback-spring.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;configuration&gt; &lt;appender name=&quot;consoleLog&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;pattern&gt; %d - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=&quot;fileInfoLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;!--滚动策略,每天一个日志--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--路径--&gt; &lt;fileNamePattern&gt; F:\\log\\tomcat\\info.%d.log &lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;appender name=&quot;fileErrorLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;!--滚动策略--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--路径--&gt; &lt;fileNamePattern&gt; F:\\log\\tomcat\\error.%d.log &lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;consoleLog&quot;/&gt; &lt;appender-ref ref=&quot;fileInfoLog&quot;/&gt; &lt;appender-ref ref=&quot;fileErrorLog&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt;","categories":[{"name":"SpringBoot实战","slug":"SpringBoot实战","permalink":"http://yoursite.com/categories/SpringBoot实战/"}],"tags":[{"name":"日志框架","slug":"日志框架","permalink":"http://yoursite.com/tags/日志框架/"}]},{"title":"微信点餐系统-数据库设计","slug":"微信点餐系统-数据库设计","date":"2019-09-18T01:36:50.000Z","updated":"2019-10-18T01:40:18.655Z","comments":true,"path":"2019/09/18/微信点餐系统-数据库设计/","link":"","permalink":"http://yoursite.com/2019/09/18/微信点餐系统-数据库设计/","excerpt":"","text":"数据库设计表的的构成类目表，商品表，订单主表，订单详情表 日期时间类型设置默认时间，DEFAULT CURRENT_TIMESTAMP时间类型字段自动更新数据，ON UPDATE CURRENT_TIMESTAMP SQL UNIQUE 约束UNIQUE约束唯一标识数据库表中的每条记录。UNIQUE和PRIMARY KEY 约束均为列或列激活提供了唯一性的保证。PRIMARY KEY 拥有自动定义的 UNIQUE约束。请注意，每个表可以有多个UNIQUE约束，但是每个表只能有一个 PRIMARY KEY 约束。 数据库编码使用 UTF-8 unicode(uftf8mb4)可以存表情","categories":[{"name":"SpringBoot实战","slug":"SpringBoot实战","permalink":"http://yoursite.com/categories/SpringBoot实战/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"TCP的三次握手","slug":"TCP的三次握手","date":"2019-05-22T07:51:17.000Z","updated":"2019-10-06T14:43:24.273Z","comments":true,"path":"2019/05/22/TCP的三次握手/","link":"","permalink":"http://yoursite.com/2019/05/22/TCP的三次握手/","excerpt":"","text":"TCP的三次握手","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/计算机网络/"}],"tags":[{"name":"TCP的三次握手","slug":"TCP的三次握手","permalink":"http://yoursite.com/tags/TCP的三次握手/"}]},{"title":"网络基础知识","slug":"网络基础知识讲解","date":"2019-04-25T10:40:12.000Z","updated":"2019-10-11T04:09:00.540Z","comments":true,"path":"2019/04/25/网络基础知识讲解/","link":"","permalink":"http://yoursite.com/2019/04/25/网络基础知识讲解/","excerpt":"","text":"OSI开放式互联参考模型 物理层： 定义物理设备标准（网线类型、光纤接口类型、各种传输介质的传输速率）,主要作用：传输比特流0101二进制数据 —&gt; 转化为电流强弱 —&gt; 0101 数模转换和模数转换 单位:比特 （网卡） 数据链路层： 定义了如何格式化数据以进行传输，和控制对物理介质的访问。主要作用：提供错误检测和纠正，确保数据传输可靠性。该层将比特数据组成为帧。（交换机） 网络层： 将网络地址翻译成对应的物理地址，决定数据从发送方路由到接收方，单位是数据包。有IP协议）路由器 传输层： 解决主机间的数据传输。（传输协议，流量控制，接收方接收数据快慢程度，规定发送速率；还可以分割大的数据包；TCP和UDP协议） 会话层： 定义不同机器上的用户之间建立及管理回话，解决应用程序之间的通信，自动收发包和寻址的功能 表示层： 解决不同操作系统之间的通信语法问题。信息的语法语义，加密解密，转换翻译 应用层： 规定接收方发送方必须使用一个固定长度的消息头，消息头必须使用固定的组成继续消息体的长度，关注TCP/IP协议中的http协议 OSI 参考模型并不是一个标准，概念性框架。事实的标准是 TCP/IP 四层架构参考模型 OSI的“实现” TCP/IP协议 TCP/IP四层模型（从下到上）：链路层：获取以太网首部网络层：获取IP首部传输层：获取TCP首部应用层：HTTP数据","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/计算机网络/"}],"tags":[{"name":"OSI七层模型","slug":"OSI七层模型","permalink":"http://yoursite.com/tags/OSI七层模型/"}]}]}