<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Page 2 | Contunued Story</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta name="description" content="Like a bird in the sky">
<meta property="og:type" content="website">
<meta property="og:title" content="Contunued Story">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Contunued Story">
<meta property="og:description" content="Like a bird in the sky">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Contunued Story">
<meta name="twitter:description" content="Like a bird in the sky">
  
    <link rel="alternate" href="/atom.xml" title="Contunued Story" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body>


  
  
  <div class="site-header-image">
    <img id="originBg" width="100%" alt="Hike News" src="">
  </div>

  <div id="header-blur" class="site-header-image blur" style="position: absolute; top:0; height: 207px; min-height: 207px; min-width: 100%;">
    <img id="blurBg" width="100%" style="top: 96%" alt="Hike News" src="">
  </div>

  <script>
        var imgUrls = "css/images/pose01.jpg,https://source.unsplash.com/collection/954550/1920x1080,https://source.unsplash.com/collection/954550/1920x1081".split(",");
        var random = Math.floor((Math.random() * imgUrls.length ));
        if (imgUrls[random].startsWith('http') || imgUrls[random].indexOf('://') >= 0) {
          document.getElementById("originBg").src=imgUrls[random];
          document.getElementById("blurBg").src=imgUrls[random];
        } else {
          document.getElementById("originBg").src='/' + imgUrls[random];
          document.getElementById("blurBg").src='/' + imgUrls[random];
        }
    </script>




<header id="allheader" class="site-header" role="banner" 
   style="width: 100%; position: absolute; top:0; background: rgba(255,255,255,.8);"  >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="Contunued Story" rel="home"> Contunued Story </a>
            
          </h1>
          
          
            <div class="site-description">Like a bird in the sky</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">Tags</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-应用通信"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/11/应用通信/">应用通信</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/11/应用通信/" class="article-date">
	  <time datetime="2019-11-11T14:50:42.000Z" itemprop="datePublished">November 11, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/微服务实战/">微服务实战</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="HTTP-VS-RPC"><a href="#HTTP-VS-RPC" class="headerlink" title="HTTP VS RPC"></a>HTTP VS RPC</h4><ul>
<li><p>Dubbo是一个RPC框架，服务治理集成非常完善，不仅提供了服务注册发现，负载均衡，路由等面向分布式集群，面向开发测试，服务治理和监控的可视化平台。</p>
</li>
<li><p>Spring Cloud，微服务架构下的一站式解决方案，微服务之间使用Http Restful调用方式：RestTemplate 、Feign; HttpRestful:本身轻量易用，适用性强，可以很容易跨语言跨平台，或者与已有的系统交互。</p>
<h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h4><h5 id="order服务访问product的三种方式，本质上都是使用RestTemplate"><a href="#order服务访问product的三种方式，本质上都是使用RestTemplate" class="headerlink" title="order服务访问product的三种方式，本质上都是使用RestTemplate"></a>order服务访问product的三种方式，本质上都是使用RestTemplate</h5><p>order服务的调用代码块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class ClientController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line">    @GetMapping(&quot;/getProductMsg&quot;)</span><br><span class="line">    public String getProductMsg()&#123;</span><br><span class="line"></span><br><span class="line">        //1.第一种方式 ,直接使用restTemplate，url写死</span><br><span class="line">//        RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">//        String response =  restTemplate.getForObject(&quot;http://localhost:8080/msg&quot;,String.class);</span><br><span class="line"></span><br><span class="line">        //2.第二种方式 利用loadBalancerClient通过应用名获取url，然后再使用restTemplate</span><br><span class="line">//        RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">//        ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;PRODUCT&quot;);</span><br><span class="line">//        String url = String.format(&quot;http://%s:%s&quot;,serviceInstance.getHost(),serviceInstance.getPort()+&quot;/msg&quot;);</span><br><span class="line">//        String response = restTemplate.getForObject(url,String.class);</span><br><span class="line">        //3.第三种方式,利用 LoadBalanced，可在restTemplate里使用应用名字</span><br><span class="line">        String response = restTemplate.getForObject(&quot;http://PRODUCT/msg&quot;,String.class);</span><br><span class="line">        log.info(&quot;response=&#123;&#125;&quot;,response);</span><br><span class="line">        return  response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>第三种方式还需要加个配置类把RestTemplate作为一个bean配置上去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RestTemplateConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    public RestTemplate restTemplate()&#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="负载均衡器：Ribbon"><a href="#负载均衡器：Ribbon" class="headerlink" title="负载均衡器：Ribbon"></a>负载均衡器：Ribbon</h4><p>Eureka中是客户端这边做负载均衡的，而不是服务端</p>
<h5 id="客服端负载均衡器：Ribbon"><a href="#客服端负载均衡器：Ribbon" class="headerlink" title="客服端负载均衡器：Ribbon"></a>客服端负载均衡器：Ribbon</h5><ol>
<li>RestTemplate、Feign、Zuul都使用到了Ribbon</li>
<li>主要组件ServerList，IRule,ServerListFilter</li>
<li>主要流程：首先通过ServerList获取所有可用服务列表，然后通过ServerListFilter过滤掉一部分地址，通过IRule选择一个实例作为最终目标结果；</li>
</ol>
<h5 id="追踪源码自定义负载均衡策略"><a href="#追踪源码自定义负载均衡策略" class="headerlink" title="追踪源码自定义负载均衡策略"></a>追踪源码自定义负载均衡策略</h5><p>默认使用轮询  </p>
<h5 id="如何改变负载均衡策略？"><a href="#如何改变负载均衡策略？" class="headerlink" title="如何改变负载均衡策略？"></a>如何改变负载均衡策略？</h5><p>application.yml. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">users:</span><br><span class="line">  ribbon:</span><br><span class="line">    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule</span><br></pre></td></tr></table></figure>

<h4 id="Feign的使用"><a href="#Feign的使用" class="headerlink" title="Feign的使用"></a>Feign的使用</h4><ul>
<li>声明式REST客户端（伪RPC），本质上是一个远程方法，http客户端发送http请求</li>
<li>采用了基于接口的注解</li>
<li>内部使用的Ribbon做负载均衡<h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5></li>
</ul>
<ol>
<li><p>添加依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.0.0.M3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在启动主类上添加@EnableFeignClients注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class OrderApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个接口声明你要调用哪个服务的哪些方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//调用product服务的msg</span><br><span class="line">@FeignClient(name=&quot;product&quot;)</span><br><span class="line">public interface ProductClient &#123;</span><br><span class="line">    @GetMapping(&quot;/msg&quot;)</span><br><span class="line">    String productMsg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把接口注入到controller，直接调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class ClientController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductClient productClient;</span><br><span class="line">    public String getProductMsg()&#123;</span><br><span class="line">        String response = productClient.productMsg();</span><br><span class="line">        log.info(&quot;response=&#123;&#125;&quot;,response);</span><br><span class="line">        return  response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="业务流程中注意要点"><a href="#业务流程中注意要点" class="headerlink" title="业务流程中注意要点"></a>业务流程中注意要点</h5><ol>
<li>controller方法中如果请求带参数必须使用 @RequestBody 结合@PostMapping</li>
<li>使用谷歌的Gson工具把json字符串转为list<object><br>加入依赖<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

</object></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//使用谷歌的Gson工具</span><br><span class="line">try &#123;</span><br><span class="line">    orderDetailList = gson.fromJson(orderForm.getItems(),new TypeToken&lt;List&lt;OrderDetail&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    log.error(&quot;【json转换】错误,string=&#123;&#125;&quot;,orderForm.getItems());</span><br><span class="line">    throw new OrderException(ResultEnum.PARAM_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="整合接口打通下单流程"><a href="#整合接口打通下单流程" class="headerlink" title="整合接口打通下单流程"></a>整合接口打通下单流程</h4><ol>
<li>查询商品信息（调用商品服务）</li>
<li>计算总价 (遍历购物车的商品，单价*数量，累加 )</li>
<li>扣库存（调用商品服务）</li>
<li>订单入库</li>
</ol>
<p>核心业务代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public OrderDTO cteate(OrderDTO orderDTO) &#123;</span><br><span class="line">        String orderId = KeyUtil.getUniqueKey();</span><br><span class="line">        // 查询商品信息（调用商品服务）</span><br><span class="line">        List&lt;String&gt; productIdList = orderDTO.getOrderDetailList().stream()</span><br><span class="line">                .map(OrderDetail::getProductId)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        List&lt;ProductInfo&gt; productInfoList = productClient.listForOrder(productIdList);</span><br><span class="line">        // 计算总价</span><br><span class="line">        BigDecimal orderAmount = new BigDecimal(0);</span><br><span class="line">        for(OrderDetail orderDetail :orderDTO.getOrderDetailList())&#123;</span><br><span class="line">            for(ProductInfo productInfo : productInfoList)&#123;</span><br><span class="line">                    if(orderDetail.getProductId().equals(productInfo.getProductId()))&#123;</span><br><span class="line">                        //单价*数量</span><br><span class="line">                        orderAmount = productInfo.getProductPrice()</span><br><span class="line">                                .multiply(new BigDecimal(orderDetail.getProductQuantity()))</span><br><span class="line">                                .add(orderAmount);</span><br><span class="line">                        BeanUtils.copyProperties(productInfo,orderDetail);</span><br><span class="line">                        orderDetail.setOrderId(orderId);</span><br><span class="line">                        orderDetail.setDetailId(KeyUtil.getUniqueKey());</span><br><span class="line">                        //订单详情入库</span><br><span class="line">                        orderDetailRepository.save(orderDetail);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;CardDTO&gt;cardDTOList = orderDTO.getOrderDetailList().stream()</span><br><span class="line">                .map(e -&gt; new CardDTO(e.getProductId(),e.getProductQuantity()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        //TODO 扣库存（调用商品服务）</span><br><span class="line">        productClient.decreaseStock(cardDTOList);</span><br><span class="line">        //订单入库</span><br><span class="line">        OrderMaster orderMaster = new OrderMaster();</span><br><span class="line">        orderDTO.setOrderId(KeyUtil.getUniqueKey());</span><br><span class="line">        BeanUtils.copyProperties(orderDTO,orderMaster);</span><br><span class="line">        orderMaster.setOrderAmount(orderAmount);</span><br><span class="line">        orderMaster.setOrderStatus(OrderStatusEnum.NEW.getCode());</span><br><span class="line">        orderMaster.setPayStatus(PayStatusEnum.WAIT.getCode());</span><br><span class="line"></span><br><span class="line">        orderMasterRepository.save(orderMaster);</span><br><span class="line">        return orderDTO;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="项目改成多模块"><a href="#项目改成多模块" class="headerlink" title="项目改成多模块"></a>项目改成多模块</h4><h5 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h5><ol>
<li>不能把自己数据表对应的实体类给暴露出去</li>
<li>同一个对象在多处定义</li>
<li>自己定义自己的接口暴露给外部调用</li>
</ol>
<h5 id="要拆分成的模块"><a href="#要拆分成的模块" class="headerlink" title="要拆分成的模块"></a>要拆分成的模块</h5><ul>
<li>product-server :所有的业务逻辑</li>
<li>product-client ：对外暴露的接口 获取商品列表、扣库存</li>
<li>product-common :公用的对象</li>
</ul>
<h5 id="如何打包商品服务的jar包给订单服务调用？"><a href="#如何打包商品服务的jar包给订单服务调用？" class="headerlink" title="如何打包商品服务的jar包给订单服务调用？"></a>如何打包商品服务的jar包给订单服务调用？</h5><p>mvn -Dmaven.test.skip=true -U clean install (将jar包清理且安装到本地)</p>
<p>如何启动且调用？  </p>
<ol>
<li>启动商品服务</li>
<li>启动订单服务<br>postman访问接口即可。</li>
</ol>
<h5 id="同步or异步"><a href="#同步or异步" class="headerlink" title="同步or异步"></a>同步or异步</h5><ol>
<li>通过消息中间件，解耦,服务间的交互变得更加灵活</li>
<li>如果都使用同步服务，开销太大</li>
<li>可以通过消息队列解决同步的问题，使之变成异步</li>
<li>看一下，这个图中的消息中间件的作用。</li>
</ol>
<p><img src="/2019/11/11/应用通信/%E5%BA%94%E7%94%A8%E9%80%9A%E4%BF%A1%5C%E6%B6%88%E6%81%AF%E5%BC%82%E6%AD%A5.jpg" alt></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/微服务实战/">微服务实战</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Java的IO机制"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/10/Java的IO机制/">Java的IO机制</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/10/Java的IO机制/" class="article-date">
	  <time datetime="2019-11-10T14:29:14.000Z" itemprop="datePublished">November 10, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java常用类库与技巧/">Java常用类库与技巧</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java常用类库与技巧/">Java常用类库与技巧</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IO机制/">IO机制</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-J-U-C包的梳理"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/10/J-U-C包的梳理/">J.U.C包的梳理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/10/J-U-C包的梳理/" class="article-date">
	  <time datetime="2019-11-10T12:28:36.000Z" itemprop="datePublished">November 10, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java多线程与并发/">Java多线程与并发</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>JUC包(java.util.concurrent)：提供了并发编程的解决方案，主要分为以下5类：</p>
<ul>
<li>线程执行器executor</li>
<li>锁locks</li>
<li>原子变量类atomic</li>
<li>并发工具类tools</li>
<li>并发容器</li>
</ul>
<p><img src="/2019/11/10/J-U-C包的梳理/JUC%E5%8C%85%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.jpg" alt></p>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><hr>
<p><img src="/2019/11/10/J-U-C包的梳理/J-U-C%E5%8C%85%E7%9A%84%E6%A2%B3%E7%90%86%5CExecutor%E6%A1%86%E6%9E%B6.jpg" alt></p>
<p><strong>J.U.C的三个Executor接口</strong></p>
<ul>
<li><p><strong>Executor</strong>:运行新任务的简单接口，将任务提交和任务执行细节解耦</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//直接启动线程</span><br><span class="line">Thread t = new Thread();</span><br><span class="line">t.start();</span><br><span class="line">//交给execute</span><br><span class="line">Thread t = new Thread();</span><br><span class="line">execute.execute(t);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ExecutorService</strong>:具备管理执行器和任务生命周期的方法，提交任务机制更完善<br>例如，其中submit方法传入了Callable,弥补了Runnable无法返回结果的短板，因此较Executor提供了更加完善的提交机制</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ScheduledExecutorService</strong>:扩展了ExecutorService，同时支持Future和定期执行任务</p>
</li>
</ul>
<h2 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h2><hr>
<p>其中 CAS 是java.util.concurrent.atomic包的基础</p>
<p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li>AtomicInteger：整形原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：原子更新引用类型里的字段原子类</li>
<li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<h3 id="AtomicInteger-的使用"><a href="#AtomicInteger-的使用" class="headerlink" title="AtomicInteger 的使用"></a>AtomicInteger 的使用</h3><p><strong>AtomicInteger 类常用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final int get() //获取当前的值</span><br><span class="line">public final int getAndSet(int newValue)//获取当前的值，并设置新的值</span><br><span class="line">public final int getAndIncrement()//获取当前的值，并自增</span><br><span class="line">public final int getAndDecrement() //获取当前的值，并自减</span><br><span class="line">public final int getAndAdd(int delta) //获取当前的值，并加上预期的值</span><br><span class="line">boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span><br><span class="line">public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span><br></pre></td></tr></table></figure>

<p><strong>AtomicInteger 类的使用示例</strong><br>使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class AtomicIntegerTest &#123;</span><br><span class="line">        private AtomicInteger count = new AtomicInteger();</span><br><span class="line">      //使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span><br><span class="line">        public void increment() &#123;</span><br><span class="line">                  count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       public int getCount() &#123;</span><br><span class="line">                return count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AtomicInteger-类的原理"><a href="#AtomicInteger-类的原理" class="headerlink" title="AtomicInteger 类的原理"></a>AtomicInteger 类的原理</h3><p>AtomicInteger 线程安全原理简单分析</p>
<p>AtomicInteger 类的部分源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span><br><span class="line">   private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">   private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           valueOffset = unsafe.objectFieldOffset</span><br><span class="line">               (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">       &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private volatile int value;</span><br></pre></td></tr></table></figure>

<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><hr>
<p>AQS 是java.util.concurrent.locks包以及一些常用类比如：Semophore,ReentrantLock类的基础</p>
<ul>
<li><p>Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</p>
<p><img src="/2019/11/10/J-U-C包的梳理/Semaphore.jpg" alt></p>
</li>
<li><p>CountDownLatch （倒计时器）： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</p>
</li>
</ul>
<p><img src="/2019/11/10/J-U-C包的梳理/CountDownLatch.jpg" alt></p>
<ul>
<li><p>CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<p><img src="/2019/11/10/J-U-C包的梳理/CyclicBarrier.jpg" alt></p>
</li>
<li><p>CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p>
</li>
<li><p>交换器 Exchanger</p>
<p><img src="/2019/11/10/J-U-C包的梳理/Exchanger.jpg" alt></p>
</li>
</ul>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><hr>
<p>JDK提供的这些容器大部分在 java.util.concurrent 包中。</p>
<ul>
<li>ConcurrentHashMap: 线程安全的HashMap</li>
<li>CopyOnWriteArrayList: 线程安全的List，在读多写少的场合性能非常好，远远好于Vector.</li>
<li>ConcurrentLinkedQueue: 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。</li>
<li>BlockingQueue: 这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li>
<li>ConcurrentSkipListMap: 跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap 的诞生。在ConcurrentHashMap中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。</p>
<p>以下两各问题在 ConcurrentHashMap 有专门的讲解</p>
<ul>
<li>ConcurrentHashMap 和 Hashtable 的区别</li>
<li>ConcurrentHashMap线程安全的具体实现方式/底层具体实现</li>
</ul>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>提供可阻塞的入队和出队操作</p>
<p>主要用于生产者-消费者问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p>
<p>在多线程场景时生产者线程在队列尾部添加元素，而消费者线程在队列头部消费元素，通过这种方式能够达到将任务的生产和消费进行隔离的目的</p>
<p> <img src="/2019/11/10/J-U-C包的梳理/BlockingQueue.jpg" alt></p>
<p>由以下七个实现类， 都是线程安全</p>
<p><img src="/2019/11/10/J-U-C包的梳理/BlockingQueue%E5%AD%90%E7%B1%BB.jpg" alt></p>
<p><strong>下面主要介绍一下:ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue，这三个 BlockingQueue 的实现类。</strong></p>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p><strong>ArrayBlockingQueue</strong> 是 BlockingQueue 接口的有界队列实现类，底层采用<strong>数组</strong>来实现。ArrayBlockingQueue一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p>
<p>ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static ArrayBlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;Integer&gt;(10,true);</span><br></pre></td></tr></table></figure>

<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p><strong>LinkedBlockingQueue</strong> 底层基于<strong>单向链表</strong>实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足FIFO的特性，与ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于Integer.MAX_VALUE。</p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p><strong>PriorityBlockingQueue</strong> 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java多线程与并发/">Java多线程与并发</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Executor/">Executor</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JUC包的梳理/">JUC包的梳理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发容器/">并发容器</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-ConcurrentHashMap"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/10/ConcurrentHashMap/">ConcurrentHashMap</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/10/ConcurrentHashMap/" class="article-date">
	  <time datetime="2019-11-10T11:34:16.000Z" itemprop="datePublished">November 10, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java多线程与并发/">Java多线程与并发</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><ul>
<li>早期Java类提供的哈希表的实现</li>
<li>线程安全：涉及到修改Hashtable的方法，使用synchronized修饰</li>
<li>串行化的方式运行，性能较差</li>
</ul>
<h2 id="如何优化Hashtable"><a href="#如何优化Hashtable" class="headerlink" title="如何优化Hashtable?"></a>如何优化Hashtable?</h2><ol>
<li><p>通过锁细粒度化，将整锁拆解成多个锁进行优化</p>
<ul>
<li><p>早期的ConcurrentHashMap：通过分段锁Segment来实现</p>
</li>
<li><p>当前的ConcurrentHashMap:CAS+synchronized使锁更细化</p>
<p><img src="/2019/11/10/ConcurrentHashMap/ConcurrentHashMap.jpg" alt></p>
<p>只是锁住每个 table 的首节点，所以只要 Hash 不冲突，就不会产生并发。</p>
</li>
</ul>
</li>
<li><p>使用Collections.synchronizedMap(hashMap);将HashMap包装成线程安全的。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p>
</li>
</ol>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ol>
<li>出自JUC包</li>
<li>成员变量与HashMap相似；sizeCtl 是 ConcurrentHashMap 特有的成员变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//用来初始化或扩容的控制位标示量</span><br><span class="line"> private transient volatile int sizeCtl;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    //不能放入为null的key</span><br><span class="line">    if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">    //去计算key的hash值</span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    int binCount = 0;</span><br><span class="line">    //多数组的元素更新是使用CAS机制，需要不断的去做失败重试</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        //数组为空初始化</span><br><span class="line">        if (tab == null || (n = tab.length) == 0)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        //不等于0我们就通过hash值来找到f(头结点),根据定位到的元素检查是否存在</span><br><span class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">            //如果没有则尝试使用CAS进行添加，添加失败则break，进入下一次循环</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   // no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        //如果被别的线程正在移动，我们就协助其扩容</span><br><span class="line">        else if ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        else &#123;</span><br><span class="line">            V oldVal = null;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                //判断f是否是链表的头结点，fh代表的是头结点的hash值</span><br><span class="line">                if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    //如果是链表的头结点，初始化计数器binCount，</span><br><span class="line">                    遍历链表。如果存在我们就去更新value，如果不存在就在链表尾部添加新的结点</span><br><span class="line">                    if (fh &gt;= 0) &#123;</span><br><span class="line">                        binCount = 1;</span><br><span class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            if (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            if ((e = e.next) == null) &#123;</span><br><span class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = 2;</span><br><span class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != null) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (binCount != 0) &#123;</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal != null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ConcurrentHashMap：put逻辑</strong>  </p>
<ol>
<li>判断Node[]数组是否初始化，没有进行初始化操作</li>
<li>通过hash定位数组的索引坐标之后，判断当前下标是否有元素，如果没有则利用CAS进行添加，添加失败进行下次循环</li>
<li>检查内部是否正在扩容，如果扩容，就帮他一块扩容</li>
<li>使用syn锁住当前下标,如果是链表则执行链表插入，如果是树，则进行树的操作</li>
<li>判断链表长度是否大于8，超过8进行树化</li>
</ol>
<p><strong>ConcurrentHashMap总结：比起Segment，锁拆的更细</strong></p>
<ul>
<li>首先使用无锁操作CAS插入头结点，失败则循环重试</li>
<li>若头结点已存在，则尝试获取头结点的同步锁，再进行操作  </li>
</ul>
<h2 id="HashMap、Hashtable、ConcurrentHashMap三者的区别"><a href="#HashMap、Hashtable、ConcurrentHashMap三者的区别" class="headerlink" title="HashMap、Hashtable、ConcurrentHashMap三者的区别"></a>HashMap、Hashtable、ConcurrentHashMap三者的区别</h2><ul>
<li>HashMap线程不安全，数组+链表+红黑树</li>
<li>Hashtable线程安全，锁住整个对象，效率低，数组+链表</li>
<li>ConcurrentHashMap线程安全，CAS+同步锁，数组+链表+红黑树</li>
<li>Hashap的key、value均可为null,而其他的两个类均不支持</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java多线程与并发/">Java多线程与并发</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hashtable/">Hashtable</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-HashMap"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/10/HashMap/">HashMap</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/10/HashMap/" class="article-date">
	  <time datetime="2019-11-10T08:17:26.000Z" itemprop="datePublished">November 10, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java常用类库与技巧/">Java常用类库与技巧</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Map的集合"><a href="#Map的集合" class="headerlink" title="Map的集合"></a>Map的集合</h4><p><img src="/2019/11/10/HashMap/%E9%9B%86%E5%90%88%E4%B9%8BMap.jpg" alt></p>
<h4 id="HashMap-Java8以前-：数组-链表"><a href="#HashMap-Java8以前-：数组-链表" class="headerlink" title="HashMap(Java8以前)：数组+链表"></a>HashMap(Java8以前)：数组+链表</h4><p><img src="/2019/11/10/HashMap/HashMapJava8%E4%BB%A5%E5%89%8D.jpg" alt></p>
<ol>
<li>HashMap的数组长度再没有给他赋任何初始值的时候默认16，一个长度为16的数组中每个元素存储的就是链表的头节点<br>，通过hash(key.hashCOde())%len 函数去取模获得要添加的元素存放的数组的位置</li>
<li>HashMap的hash算法是通过位运算来进行的相比取模运算效率更高</li>
<li>存在极端情况，通过hash散列运算总是得到相同的值，即分配到同一个桶中，会使得某个桶的链表很长</li>
</ol>
<h4 id="HashMap-Java8以后-：数组-链表-红黑树"><a href="#HashMap-Java8以后-：数组-链表-红黑树" class="headerlink" title="HashMap(Java8以后)：数组+链表+红黑树"></a>HashMap(Java8以后)：数组+链表+红黑树</h4><p><img src="/2019/11/10/HashMap/HashMapJava8%E4%BB%A5%E5%90%8E.jpg" alt><br>1.红黑树的算法和实现</p>
<h4 id="HashMap的内部结构解析"><a href="#HashMap的内部结构解析" class="headerlink" title="HashMap的内部结构解析"></a>HashMap的内部结构解析</h4><p>HashMap相关源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>Node的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>HashMap可以看做通过数组Node&lt;K,V&gt;这个table，和链表组成的数据结构。<br>Node是由hash值，键值对，以及指向的下一个节点来组成的；  </li>
<li>而数组被分为一个个的bucket，通过hash值决定了键值对在这个数据的寻址，hash值相同的键值对则以链表的形式来存储，而如果链表的大小超过了 <em>TREEIFY_THRESHOLD =8</em> 就会被改造成红黑树。当某bucket上面的元素的总数因为删除而变得低于阈值 <em>UNTREEIFY_THRESHOLD =6</em> 了之后，红黑树又被转成链表以保持更高的性能！</li>
</ol>
<h5 id="HashMap的构造函数"><a href="#HashMap的构造函数" class="headerlink" title="HashMap的构造函数"></a>HashMap的构造函数</h5><p>源码</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span><br><span class="line">* (16) and the default load factor (0.75).</span><br><span class="line">*/</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>根据构造函数可以看出HashMap 中的table数组并没有在开始初始化好，而是赋上了初始值，因为可以推断HashMap是按照lazyLoad去加载</p>
<h5 id="HashMap的-put-方法"><a href="#HashMap的-put-方法" class="headerlink" title="HashMap的 put()方法"></a>HashMap的 put()方法</h5><p>源码分析加注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    //根据源码可以看出如果数组为空就调用resize()方法给它初始化数组</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    //做hash运算，算出键值对在table里面的具体位置，得到的运算还没有元素存储到里面则会直接new一个该键值对的node,放到该位置当中</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        //如果发现同样的位置存在同样的已经存在键值对，且键和传入进来的键一致，则直接替换数组里面的元素</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        //当前位置存储的是否是已经树化了之后的节点，如果是树化了的话则按照树的方式尝试存储键值对</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        //如果不是树化了，则按照链表的插入方式往链表后面添加元素，同时判断链表元素的总数，一旦超过TREEIFY_THRESHOLD，则将链表进行树化</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果插入的键位存在于hashMap中则对对应的键位进行值的更新操作</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    //而当我们的HashMap的size大于阈值的时候也通用会调用resize()对HashMap进行扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人理解： 根据源码可以看出如果数组为空就给它初始化数组（调用resize()方法），而当我们的HashMap的size大于阈值的时候也通用会调用resize()对HashMap进行扩容,因此resize方法即具备初始化又具备扩容的功能。</p>
<p><strong>put方法逻辑总结</strong>  </p>
<ol>
<li>若HashMap未被初始化，则进行初始化操作；</li>
<li>对key求Hash值，依据Hash值计算下标；</li>
<li>若未发生碰撞，则直接放入桶中；</li>
<li>若发生碰撞，则以链表的方式链接到后面；</li>
<li>若链表长度超过阈值，且HashMap匀速超过最低树化容量，则将链表转成红黑树；</li>
<li>若节点已经存在，则用新值替代旧值；</li>
<li>若桶满了（默认容量16*扩容因子0.75），就需要resize(扩容2倍后重排)；</li>
</ol>
<h5 id="HashMap的-get-方法"><a href="#HashMap的-get-方法" class="headerlink" title="HashMap的 get()方法"></a>HashMap的 get()方法</h5><p>源码分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get方法逻辑总结</strong>  </p>
<ol>
<li>使用键对象的hashCode 通过hash算法找到bucket的位置；</li>
<li>找到bucket位置之后调用 key.equals(k) 去找到链表中正确的节点最终找到要找的值，并返回；</li>
</ol>
<h4 id="HashMap如何有效减少碰撞"><a href="#HashMap如何有效减少碰撞" class="headerlink" title="HashMap如何有效减少碰撞"></a>HashMap如何有效减少碰撞</h4><ul>
<li>扰动函数：促使元素位置分布均匀，减少碰撞机率；对于很多元素我们能够通过数组来直接去获取，hash算法内部实现目的是让不同的对象返回不同的hashCode</li>
<li>使用final对象，并采用合适的equals和hashCode()方法:final类建议作为key是利用了其不可变性，如果一个key可以随便修改，那么修改后在hashmap就找不到了；适合String,Integer这样的键</li>
</ul>
<h4 id="HashMap的-hash-方法"><a href="#HashMap的-hash-方法" class="headerlink" title="HashMap的 hash()方法"></a>HashMap的 hash()方法</h4><p>源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先获取key的hashCode,再将高位数移动16位，再与原先的数据异或运算<br><img src="/2019/11/10/HashMap/%E4%BB%8E%E8%8E%B7%E5%8F%96hash%E5%88%B0%E6%95%A3%E5%88%97%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="从获取hash到散列的过程"><br>如上图：key的hashCode是返回int散列值，如果直接拿这个散列值作为下标去访问hashMap数组的话，考虑到二进制的三十二位int范围</li>
</ol>
<p>-2147483648到2147483648，只要hash函数映射的均匀一般很难出现碰撞，一个40亿长度的数组内存是放不下的，况且HashMap的最初始数组大小才16，所以直接拿散列值用不现实！  直接将高半区向右移动16位再跟自己去做异或，可以混合原始hash码的高位和低位以此来加大低位的随机性，混合后后的低位掺杂了高位的特征，从速度功效考虑，也不会有太大的开销。</p>
<h4 id="HashMap的-扩容方法"><a href="#HashMap的-扩容方法" class="headerlink" title="HashMap的 扩容方法"></a>HashMap的 扩容方法</h4><p>当hashMap无法装载更多的元素时，对象就需要扩大数组的长度；使用一个新的较大的数组来代替老的数组；hashMap的默认负载因子是0.75；当一个hashMap填满了75%的bucket的时候，将会创建原来hashMap大小的两倍的bucket数组来重新调整map的大小，这个过程是 rehashing</p>
<h4 id="HashMap扩容问题"><a href="#HashMap扩容问题" class="headerlink" title="HashMap扩容问题"></a>HashMap扩容问题</h4><ul>
<li>多线程环境下，调整大小会存在条件竞争，容易造成死锁</li>
<li>rehashing是一个比较耗时的过程</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java常用类库与技巧/">Java常用类库与技巧</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HashMap/">HashMap</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Java集合框架基础"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/10/Java集合框架基础/">Java集合框架基础</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/10/Java集合框架基础/" class="article-date">
	  <time datetime="2019-11-10T07:50:41.000Z" itemprop="datePublished">November 10, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java常用类库与技巧/">Java常用类库与技巧</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>优秀的算法和数据结构被封装到了Java的集合框架</p>
<h2 id="数据结构重点："><a href="#数据结构重点：" class="headerlink" title="数据结构重点："></a>数据结构重点：</h2><ul>
<li>数组和链表的区别；</li>
<li>链表的操作，如反转，链表环路检测，双向链表，循环链表相关操作</li>
<li>队列，栈的应用</li>
<li>二叉树的遍历方式及其递归和非递归的实现</li>
<li>红黑树的旋转</li>
</ul>
<h2 id="算法重点："><a href="#算法重点：" class="headerlink" title="算法重点："></a>算法重点：</h2><ul>
<li>内部排序：如递归排序、交换排序（冒泡、快排）、插入排序、选择排序</li>
<li>外部排序：掌握如何利用有限的内存配合海量的外部存储来处理超大数据集，写不出来有思路</li>
</ul>
<h2 id="Java集合框架图"><a href="#Java集合框架图" class="headerlink" title="Java集合框架图"></a>Java集合框架图</h2><p><img src="/2019/11/10/Java集合框架基础/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.jpg" alt></p>
<h2 id="List-Set-Map三者的区别"><a href="#List-Set-Map三者的区别" class="headerlink" title="List,Set,Map三者的区别"></a>List,Set,Map三者的区别</h2><ul>
<li>List(对付顺序的好帮手)： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li>
<li>Set(注重独一无二的性质): 不允许重复的集合。不会有多个元素引用相同的对象。</li>
<li>Map(用Key来搜索的专家): 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li>
</ul>
<h2 id="集合之List和Set"><a href="#集合之List和Set" class="headerlink" title="集合之List和Set"></a>集合之List和Set</h2><p><img src="/2019/11/10/Java集合框架基础/List%E5%92%8CSet.jpg" alt></p>
<h3 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h3><ol>
<li><p><strong>是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p>
</li>
<li><p><strong>底层数据结构：</strong> Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p>
</li>
<li><p><strong>插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行add(E e) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 <strong>② LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></p>
</li>
<li><p><strong>是否支持快速随机访问：</strong> LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index) 方法)。</p>
</li>
<li><p><strong>内存空间占用：</strong> ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
</li>
</ol>
<h4 id="补充内容-RandomAccess接口"><a href="#补充内容-RandomAccess接口" class="headerlink" title="补充内容:RandomAccess接口"></a>补充内容:RandomAccess接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface RandomAccess &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p>
<p>在 Collections.binarySearch()方法中，它要判断传入的list 是否 RamdomAccess 的实例，如果是，调用indexedBinarySearch()方法，如果不是，那么调用iteratorBinarySearch()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt;</span><br><span class="line">    int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;</span><br><span class="line">        if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">            return Collections.indexedBinarySearch(list, key);</span><br><span class="line">        else</span><br><span class="line">            return Collections.iteratorBinarySearch(list, key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！</p>
<p><strong>下面再总结一下 list 的遍历方式选择：</strong></p>
<ul>
<li>实现了 RandomAccess 接口的list，优先选择普通 for 循环 ，其次 foreach,</li>
<li>未实现 RandomAccess接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环</li>
</ul>
<h4 id="补充内容-双向链表和双向循环链表"><a href="#补充内容-双向链表和双向循环链表" class="headerlink" title="补充内容:双向链表和双向循环链表"></a>补充内容:双向链表和双向循环链表</h4><p><strong>双向链表：</strong> 包含两个指针，一个prev指向前一个节点，一个next指向后一个节点。</p>
<p><strong>双向循环链表：</strong> 最后一个节点的 next 指向head，而 head 的prev指向最后一个节点，构成一个环。</p>
<h3 id="ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？"><a href="#ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？" class="headerlink" title="ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？"></a>ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？</h3><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p>
<p>Arraylist不是同步的，所以在不需要保证线程安全时建议使用Arraylist。</p>
<h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<h3 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
<table>
<thead>
<tr>
<th align="center">HashMap</th>
<th align="center">HashSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了Map接口</td>
<td align="center">实现Set接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put（）</code>向map中添加元素</td>
<td align="center">调用 <code>add（）</code>方法向Set中添加元素</td>
</tr>
<tr>
<td align="center">HashMap使用键（Key）计算Hashcode</td>
<td align="center">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</td>
</tr>
</tbody></table>
<h2 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h2><p>当你把对象加入<code>HashSet</code>时，HashSet会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用<code>equals（）</code>方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。（摘自我的Java启蒙书《Head fist java》第二版）</p>
<p><strong>hashCode（）与equals（）的相关规定：</strong></p>
<ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个equals方法返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<p><strong>==与equals的区别</strong></p>
<ol>
<li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li>
<li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li>
<li>==指引用是否相同 equals()指的是值是否相同</li>
</ol>
<h3 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h3><p>在HashMap中有详细分析，这里不再累述；</p>
<h2 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h4><ul>
<li><strong>Arraylist：</strong> Object数组</li>
<li><strong>Vector：</strong> Object数组</li>
<li><strong>LinkedList：</strong> 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)</li>
</ul>
<h4 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. Set</h4><ul>
<li><strong>HashSet（无序，唯一）:</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>
<li><strong>LinkedHashSet：</strong> LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li>
<li><strong>TreeSet（有序，唯一）：</strong> 红黑树(自平衡的排序二叉树。)</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li>
<li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>
<li><strong>Hashtable：</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><strong>TreeMap：</strong> 红黑树（自平衡的排序二叉树）</li>
</ul>
<h2 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h2><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java常用类库与技巧/">Java常用类库与技巧</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/List/">List</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Set/">Set</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-服务拆分"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/08/服务拆分/">服务拆分</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/08/服务拆分/" class="article-date">
	  <time datetime="2019-11-08T09:00:20.000Z" itemprop="datePublished">November 8, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/微服务实战/">微服务实战</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="微服务拆分的起点和重点"><a href="#微服务拆分的起点和重点" class="headerlink" title="微服务拆分的起点和重点"></a>微服务拆分的起点和重点</h4><h5 id="微服务如何拆分："><a href="#微服务如何拆分：" class="headerlink" title="微服务如何拆分："></a>微服务如何拆分：</h5><ol>
<li>先明白起点和终点<br> 起点：既有的架构形态（老项目、新项目）<br> 终点：好的架构不是设计出来的，而是进化而来的。进化一直在演进  </li>
<li>需要考虑的因素与坚持的原则</li>
</ol>
<h5 id="不适合用微服务的业务场景"><a href="#不适合用微服务的业务场景" class="headerlink" title="不适合用微服务的业务场景"></a>不适合用微服务的业务场景</h5><ol>
<li>系统中包含很多很多强事务场景的</li>
<li>业务相对稳定，迭代周期长</li>
<li>访问压力不大，可用性要求不高</li>
</ol>
<p>康威定律：沟通的问题会影响系统的设计</p>
<h4 id="点餐业务服务拆分"><a href="#点餐业务服务拆分" class="headerlink" title="点餐业务服务拆分"></a>点餐业务服务拆分</h4><p>服务拆分的方法论：&lt;可扩展的艺术&gt;</p>
<h5 id="扩展立方模型"><a href="#扩展立方模型" class="headerlink" title="扩展立方模型"></a>扩展立方模型</h5><ul>
<li>x轴：水平复制，通过副本扩展，将应用程序水平复制，通过负载均衡运行程序的多个完全一样的副本方式，来实现应用程序的伸缩性，提高应用程序的容量和可用度。</li>
<li>Z轴：数据分区，每个服务器负责一个数据子集。每个服务器运行的代码是一样的。</li>
<li>Y轴：功能解耦，将不同职责的模块，分成不同的服务<h5 id="如何拆分功能"><a href="#如何拆分功能" class="headerlink" title="如何拆分功能"></a>如何拆分功能</h5><ul>
<li>单一职责，松耦合、高内聚 ：<br> （每个服务只负责业务功能的一个单独部分。服务之间耦合度低，修改一个服务不用导致另外一个服务跟着修改，高内聚指的是服务内部相关的行为聚集在一个服务内，而不是分散在不同的服务中，需要修改一个行为时，只需要修改一个服务就行）</li>
<li>关注点分离</li>
</ul>
<ol>
<li>按职责（给我们的服务进行分类，明显按照业务领域可以划分出来的服务，职责比较单一</li>
<li>按通用性（一些基础组件，与具体的业务无关的可以划分成单独的服务 消息 用户</li>
<li>按粒度级别<h5 id="服务和数据的关系"><a href="#服务和数据的关系" class="headerlink" title="服务和数据的关系"></a>服务和数据的关系</h5></li>
</ol>
<ul>
<li>先考虑拆分业务功能，在考虑拆分业务功能对应的数据</li>
<li>无状态服务</li>
</ul>
<ol>
<li>一个数据需要被多个服务共享才能完成一个请求，这个数据就是有状态</li>
<li>把数据迁移到分布式缓存中存储，让业务服务变成无状态计算结点，后端服务能做到按需动态伸缩，在运行时动态增删结点不用考虑缓存同步问题</li>
</ol>
</li>
</ul>
<p><img src="/2019/11/08/服务拆分/%E4%B8%8D%E7%94%A8%E8%80%83%E8%99%91%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5.jpg" alt>     </p>
<h5 id="点餐业务拆分分析"><a href="#点餐业务拆分分析" class="headerlink" title="点餐业务拆分分析"></a>点餐业务拆分分析</h5><p><img src="/2019/11/08/服务拆分/%E7%82%B9%E9%A4%90%E4%B8%9A%E5%8A%A1%E6%8B%86%E5%88%86%E5%88%86%E6%9E%90.jpg" alt>  </p>
<h5 id="服务拆分的方法论：-lt-可扩展的艺术-gt"><a href="#服务拆分的方法论：-lt-可扩展的艺术-gt" class="headerlink" title="服务拆分的方法论：&lt;可扩展的艺术&gt;"></a>服务拆分的方法论：&lt;可扩展的艺术&gt;</h5><p>  扩展立方模型：  </p>
<ul>
<li>x轴：水平复制，通过副本扩展，将应用程序水平复制，通过负载均衡运行程序的多个完全一样的副本方式，来实现应用程序的伸缩性，提高应用程序的容量和可用度。</li>
<li>Z轴：数据分区，每个服务器负责一个数据子集。每个服务器运行的代码是一样的。</li>
<li>Y轴：功能解耦，将不同职责的模块，分成不同的服务</li>
</ul>
<h4 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h4><ol>
<li><p>开发商品服务和订单服务作为服务注册到 注册中心Eureka Server</p>
</li>
<li><p>每个服务的开发流程大致 连接数据库-&gt;创建所需对象-&gt;dao层-&gt;分析controller中方法的业务流程-&gt;写出需要的service方法-&gt;写controller ,注意每个方法写完后都及时单元测试</p>
</li>
<li><p>返回给前端的数据自定义VO对象</p>
</li>
<li><p>前端请求过来的数据使用form对象封装，controller传给service的数据使用DTO封装</p>
<h4 id="如何拆数据"><a href="#如何拆数据" class="headerlink" title="如何拆数据"></a>如何拆数据</h4><ol>
<li>每个微服务都有单独的数据存储，达到松耦合，其它服务避免访问别的服务的数据库。一个服务的数据，只能通过这个服务提供的api来访问，服务之间都是有隔离的。</li>
<li>依据服务特点选择不同结构的数据库类型。依据功能特点选择合适的数据库。mongodb（前端服务，对事物要求低）、Elasticsearch(ES搜索)、mysql</li>
<li>难点在确定边界</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/微服务实战/">微服务实战</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-服务注册与发现"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/08/服务注册与发现/">服务注册与发现</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/08/服务注册与发现/" class="article-date">
	  <time datetime="2019-11-08T03:15:32.000Z" itemprop="datePublished">November 8, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/微服务实战/">微服务实战</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="微服务的注册与发现-（Spring-Cloud-Eureka）："><a href="#微服务的注册与发现-（Spring-Cloud-Eureka）：" class="headerlink" title="微服务的注册与发现 （Spring Cloud Eureka）："></a>微服务的注册与发现 （Spring Cloud Eureka）：</h4><ol>
<li>基于Netflix Eureka做了二次封装</li>
<li>两个组件：</li>
</ol>
<ul>
<li>Eureka Server(注册中心）</li>
<li>Eureka Client(服务注册)  </li>
</ul>
<p>Eureka Server作为服务注册功能的服务器，它是服务注册中心，而系统中其他微服务使用Eureka Client客户端，连接到Eureka Server并维持心跳连接，这样就能监控系统中各个微服务是否正常运行</p>
<h4 id="Eureka-Server-注册中心"><a href="#Eureka-Server-注册中心" class="headerlink" title="Eureka Server 注册中心"></a>Eureka Server 注册中心</h4><h5 id="Eureka-Server的配置"><a href="#Eureka-Server的配置" class="headerlink" title="Eureka Server的配置"></a>Eureka Server的配置</h5><ol>
<li><p>新建项目 Cloud Discovery -&gt; Eureka Server</p>
</li>
<li><p>修改pom文件中spring boot 2.0.0.M3 和 spring cloud Finchley.M2的版本</p>
</li>
<li><p>启动主类EurekaApplication  添加注解 @EnableEurekaServer，表明这个有注册中心的功能</p>
</li>
<li><p>配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">    # 配置的注册地址</span><br><span class="line">      defaultZone: http://localhost:8761/eureka/</span><br><span class="line">    # 本身就是注册中心，取消注册</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">  server:</span><br><span class="line">  #Server端配置，关闭自我保护，开发环境</span><br><span class="line">    enable-self-preservation: false</span><br><span class="line"># 配置应用的名字</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka</span><br><span class="line">server:</span><br><span class="line">  port: 8761</span><br></pre></td></tr></table></figure>
</li>
<li><p>mvn打包,后台启动 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package  </span><br><span class="line">nohup java -jar target/eureka-0.0.1-SNAPSHOT.jar &gt; /dev/null 2&gt;&amp;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="Eureka-Client的配置"><a href="#Eureka-Client的配置" class="headerlink" title="Eureka Client的配置"></a>Eureka Client的配置</h5><ol>
<li>新建项目 Cloud Discovery -&gt; Eureka Client</li>
<li>修改pom文件中spring boot 2.0.0.M3 和 spring cloud Finchley.M2的版本</li>
<li>启动主类 ClientApplication  添加注解 @EnableDiscoveryClient，表明这个有注册中心的功能</li>
<li>配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">    # 配置的注册地址</span><br><span class="line">      defaultZone: http://localhost:8761/eureka/</span><br><span class="line">    # 自定义连接跳转地址</span><br><span class="line">#   instance:</span><br><span class="line">#    hostname: clientName</span><br><span class="line"># 配置应用的名字</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: client</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>EurekaClient的使用  </p>
<ol>
<li>引入依赖</li>
<li>配置上注册中心的地址</li>
<li>在启动的主类上加@EnableDiscoveryClient</li>
</ol>
<h5 id="Eureka-的高可用"><a href="#Eureka-的高可用" class="headerlink" title="Eureka 的高可用"></a>Eureka 的高可用</h5><p>eureka server实现高可用，可以将他集群，然后互相注册。client端注册所有集群eureka<br><img src="/2019/11/08/服务注册与发现/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%5CEurekaServer%E9%AB%98%E5%8F%AF%E7%94%A8.jpg" alt><br>单个server且没有client的时候，自己注册自己，会显示自己，加一个参数register-with-eureka: false会取消显示； 3个server相互注册instances栏也不显示注册的另外的server（client）实例和自己本身，registered-replicas栏里倒是可以看另外的server；<br>改动register-with-eureka: true后，另外两个server实例和自己本身将都会显示。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Eureka Server的高可用，通过多个Eureka相互注册实现。   </p>
<ul>
<li>@EnableEurekaServer @EnableEurekaClient</li>
<li>心跳检测，健康检查，负载均衡等功能</li>
<li>Eureka的高可用，生产上建议至少两台以上</li>
<li>分布式系统中，服务注册中心是最重要的部分</li>
</ul>
<h4 id="分布式下服务注册的地位和原理"><a href="#分布式下服务注册的地位和原理" class="headerlink" title="分布式下服务注册的地位和原理"></a>分布式下服务注册的地位和原理</h4><p><img src="/2019/11/08/服务注册与发现/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%5C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0.jpg" alt></p>
<p>服务端发现两种方式：  </p>
<ol>
<li>客户端发现：Eureka</li>
<li>服务端发现：Nginx,Zookeeper,Kubernetes  </li>
</ol>
<p>微服务的特点：异构  </p>
<ol>
<li>不同语言</li>
<li>不同类型的数据库</li>
</ol>
<p>SpringCloud的调用方式：REST，其他语言可实现Eureka的客户端</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/微服务实战/">微服务实战</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Eureka/">Eureka</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-微服务介绍"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/08/微服务介绍/">微服务介绍</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/08/微服务介绍/" class="article-date">
	  <time datetime="2019-11-08T02:50:52.000Z" itemprop="datePublished">November 8, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/微服务实战/">微服务实战</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务?"></a>什么是微服务?</h4><p>微服务是一种架构风格，不是组件不是框架。</p>
<ol>
<li>一系列微小的服务共同组成</li>
<li>跑在自己的进程</li>
<li>每个服务为独立的业务开发</li>
<li>独立部署</li>
<li>分布式的管理</li>
</ol>
<h4 id="什么是分布式？"><a href="#什么是分布式？" class="headerlink" title="什么是分布式？"></a>什么是分布式？</h4><p>旨在支持应用程序和服务的开发，可以利用物理架构由多个自治的处理元素，不共享内存，但通过网络发送消息合作。<br><img src="/2019/11/08/微服务介绍/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B.jpg" alt></p>
<h4 id="单体架构的优点："><a href="#单体架构的优点：" class="headerlink" title="单体架构的优点："></a>单体架构的优点：</h4><p>容易测试（本地启动完整的测试，不需要外部依赖）<br>容易部署（直接打成war包，放在tomcat下面就可以了）</p>
<h4 id="单体架构的缺点："><a href="#单体架构的缺点：" class="headerlink" title="单体架构的缺点："></a>单体架构的缺点：</h4><p>开发效率低（容易提交代码的时候造成冲突）<br>代码维护难（尤其是新人来的时候业务代码写在一块，不知从何下手）<br>部署不够灵活（任何小修改都要重新构建，构建时间特别长）<br>稳定性不够 （任何一个小问题容易让整个系统挂掉）<br>扩展性不够（无法满足高并发下的业务需求）   </p>
<h4 id="微服务架构的基础框架或组件："><a href="#微服务架构的基础框架或组件：" class="headerlink" title="微服务架构的基础框架或组件："></a>微服务架构的基础框架或组件：</h4><ol>
<li>服务注册发现</li>
<li>服务网关（路由、监控、容器、日志、授权、反爬虫）</li>
<li>后端通用服务（请求时将地址信息放在服务注册表中）</li>
<li>前端服务（通过查询注册表发现并调用后端服务，主要是聚合后端服务和暴露外部接口）</li>
</ol>
<p><img src="/2019/11/08/微服务介绍/%E7%AE%80%E5%8D%95%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.jpg" alt></p>
<h4 id="Spring-Cloud-是什么？"><a href="#Spring-Cloud-是什么？" class="headerlink" title="Spring Cloud 是什么？"></a>Spring Cloud 是什么？</h4><ul>
<li>Spring Cloud 是一个开发工具集，包含多个子项目<br>主要是基于对 Netflix 开源组件的进一步封装</li>
<li>继承了了Spring Boot 的开发便利，简化了分布式开发</li>
<li>不仅需要掌握如何使用，更要理解分布式架构的特点</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/微服务实战/">微服务实战</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Java异常"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/11/07/Java异常/">Java异常</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/11/07/Java异常/" class="article-date">
	  <time datetime="2019-11-07T13:33:15.000Z" itemprop="datePublished">November 7, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java常用类库与技巧/">Java常用类库与技巧</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="异常机制主要回答了三个问题"><a href="#异常机制主要回答了三个问题" class="headerlink" title="异常机制主要回答了三个问题"></a>异常机制主要回答了三个问题</h4><ul>
<li>what：异常类型回答了什么被抛出</li>
<li>where：异常堆栈跟踪回答了在哪抛出</li>
<li>why：异常信息回答了为什么被抛出</li>
</ul>
<h4 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h4><p><img src="/2019/11/07/Java异常/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.jpg" alt></p>
<ul>
<li>RuntimeException：不可预知的，程序应当自行避免（NullPointerException，IndexOutOfBoundsException ….. ）</li>
<li>非RuntimeExceptin：可预知的，从编译器校验的异常（IOException，SqlException…）<br>任</li>
</ul>
<h4 id="error和exceptin的区别"><a href="#error和exceptin的区别" class="headerlink" title="error和exceptin的区别"></a>error和exceptin的区别</h4><p><strong>从概念角度解析Java的异常处理机制</strong></p>
<ul>
<li>error：程序无法处理的系统错误，编译器不做检查（StackOverFlowError,OutOfMemoryError）</li>
<li>exception：程序可以处理的异常，捕获后可能恢复<br>总结：前者是程序无法处理的错误，后者是可以处理的异常</li>
</ul>
<p><strong>从责任角度看</strong>  </p>
<ol>
<li>Error属于jvm需要承担的责任</li>
<li>RuntimeException是程序应该承当的责任</li>
<li>Checked Exception可检查异常是Java编译器应该负担的责</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ErrorAndException&#123;</span><br><span class="line">    private void throwError()&#123;</span><br><span class="line">        throw new StackOverflowError();</span><br><span class="line">    &#125;</span><br><span class="line">    private void throwRuntimeException()&#123;</span><br><span class="line">        throw new RuntimeExeption</span><br><span class="line">    &#125;</span><br><span class="line">    private void throwCheckedException () throws FileNotFoundExcpetion&#123;</span><br><span class="line">        //此处编译器会报错，checkedException是必须要追踪处理的异常，要么此处加try()catch&#123;&#125;在catch中增加处理逻辑，理解这种Exception的成因结合实际业务去处理</span><br><span class="line">        //最好通过throw方式把异常抛出去，让调用模块去处理</span><br><span class="line">        throw new FileNotFoundExcpetion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常见Error以及Exception"><a href="#常见Error以及Exception" class="headerlink" title="常见Error以及Exception"></a>常见Error以及Exception</h4><h5 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h5><ol>
<li>NullPointerException-空指针异常</li>
<li>ClassCastException-类型强制转换异常</li>
<li>IllegalArguementException-传递非法参数异常</li>
<li>IndexOutOfBoundsException-下标越界异常</li>
<li>NumberFormatException-数字格式异常<h5 id="非RuntimeException"><a href="#非RuntimeException" class="headerlink" title="非RuntimeException"></a>非RuntimeException</h5></li>
<li>ClassNotFoundException -找不到指定class的异常</li>
<li>IOExceptin-IO操作异常</li>
</ol>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><ol>
<li>NotClassDefFoundError-找不到class定义的异常：<br> NotClassDefFondError的成因：<ul>
<li>类依赖的class或者jar不存在</li>
<li>类文件存在，但是存在不同域中：对应的class在Java的classpath中不可用，又或者有多个不同的类加载器重复加载了同一个class</li>
<li>大小写问题，javac编译的时候无视大小写，很肯能编译出来的class文件就与想要的不一样</li>
</ul>
</li>
<li>StackOverflowError-深递归导致栈被耗尽而抛出的异常</li>
<li>OutOfMemeryError-内存溢出异常</li>
</ol>
<h4 id="Java的异常处理机制"><a href="#Java的异常处理机制" class="headerlink" title="Java的异常处理机制"></a>Java的异常处理机制</h4><ul>
<li>抛出异常：创建异常对象，交由运行时系统处理</li>
<li>捕获异常：寻找合适的异常处理器处理异常，否则终止运行</li>
</ul>
<h4 id="Java异常的处理原则"><a href="#Java异常的处理原则" class="headerlink" title="Java异常的处理原则"></a>Java异常的处理原则</h4><ul>
<li>具体明确：抛出的异常应该能通过异常类名和message准确说明异常的类型和产出异常的愿意；</li>
<li>提早抛出：应尽可能早的发现并抛出异常，便于精确定位问题；</li>
<li>延迟捕获异常的捕获和处理应可能延迟，让掌握更多信息的作用域来处理</li>
</ul>
<h4 id="高效主流的异常处理框架"><a href="#高效主流的异常处理框架" class="headerlink" title="高效主流的异常处理框架"></a>高效主流的异常处理框架</h4><ul>
<li>设计一个通用的继承自RuntimeExceptin的异常来统一处理</li>
<li>其余异常都统一转译为上述异常AppException</li>
<li>在catch之后，抛出上述异常的子类，并提供足以定位的信息</li>
<li>由前端接受AppExcception做统一处理</li>
</ul>
<p><img src="/2019/11/07/Java异常/%E9%AB%98%E6%95%88%E4%B8%BB%E6%B5%81%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6.jpg" alt="高效主流的异常处理框架"></p>
<h4 id="try-catch的性能"><a href="#try-catch的性能" class="headerlink" title="try-catch的性能"></a>try-catch的性能</h4><h5 id="Java异常处理消耗性能的地方"><a href="#Java异常处理消耗性能的地方" class="headerlink" title="Java异常处理消耗性能的地方"></a>Java异常处理消耗性能的地方</h5><ul>
<li>try-catch块影响JVM的优化</li>
<li>异常对象实例需要保存栈快照等信息，开销较大</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Java常用类库与技巧/">Java常用类库与技巧</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/异常/">异常</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" Search…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="Search">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Connect With Us</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="https://github.com/ValarMorghulis521" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="http://weibo.com/chenshifouaili" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>Recent Posts</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2020/01/02/AQS原理以及AQS同步组件/">AQS原理以及AQS同步组件</a></h6>
              <span>January 2, 2020</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2020/01/02/乐观锁和悲观锁/">乐观锁和悲观锁</a></h6>
              <span>January 2, 2020</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/12/18/设计模式/">设计模式</a></h6>
              <span>December 18, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/19/容器部署/">容器部署</a></h6>
              <span>November 19, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/18/链路监控/">链路监控</a></h6>
              <span>November 18, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/11/18/服务容错Hystrix/">服务容错Hystrix</a></h6>
              <span>November 18, 2019</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GC相关/">GC相关</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java多线程与并发/">Java多线程与并发</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java常用类库与技巧/">Java常用类库与技巧</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Boot-实战/">Spring Boot 实战</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务实战/">微服务实战</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACID/">ACID</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOF/">AOF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/">AOP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ClassLoader/">ClassLoader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Config-Clent/">Config Clent</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Config-Server/">Config Server</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cookie和动态路由/">Cookie和动态路由</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eureka/">Eureka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Executor/">Executor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hashtable/">Hashtable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hystrix/">Hystrix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOC/">IOC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO机制/">IO机制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/InnoDB/">InnoDB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JUC包的梳理/">JUC包的梳理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM内存结构模型/">JVM内存结构模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java特性/">Java特性</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/List/">List</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyISAM/">MyISAM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OSI七层模型/">OSI七层模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RDB/">RDB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RTO/">RTO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RTT/">RTT</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/">RabbitMQ</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Set/">Set</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cliud-Stream/">Spring Cliud Stream</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud-Bus/">Spring Cloud Bus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud-Sleuth/">Spring Cloud Sleuth</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP的三次握手/">TCP的三次握手</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP的四次挥手/">TCP的四次挥手</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thread和Runnable/">Thread和Runnable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UDP/">UDP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zipkin/">Zipkin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zuul/">Zuul</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interrupt/">interrupt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lombok/">lombok</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/notify/">notify</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql调优/">sql调优</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/start和run/">start和run</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yield/">yield</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代理模式/">代理模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式锁/">分布式锁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单例模式/">单例模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/反射/">反射</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回收算法/">回收算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多路I-O复用模型/">多路I/O复用模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/密集索引/">密集索引</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工厂模式/">工厂模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/平台无关性/">平台无关性</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发容器/">并发容器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异常/">异常</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步队列/">异步队列</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/当前读/">当前读</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快照读/">快照读</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库事务/">数据库事务</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库架构/">数据库架构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/新生代垃圾收集器/">新生代垃圾收集器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日志框架/">日志框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务容错/">服务容错</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务网关/">服务网关</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/标记算法/">标记算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/滑动窗口/">滑动窗口</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/稀疏索引/">稀疏索引</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/类的装载/">类的装载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/索引/">索引</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/索引数据结构/">索引数据结构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程共享/">线程共享</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线程独占/">线程独占</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/老年代垃圾收集器/">老年代垃圾收集器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/语法/">语法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域/">跨域</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/进程和线程/">进程和线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/鉴权/">鉴权</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链路监控/">链路监控</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/锁模块/">锁模块</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/限流/">限流</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ACID/" style="font-size: 10px;">ACID</a> <a href="/tags/AOF/" style="font-size: 10px;">AOF</a> <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/ClassLoader/" style="font-size: 10px;">ClassLoader</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 10px;">ConcurrentHashMap</a> <a href="/tags/Config-Clent/" style="font-size: 10px;">Config Clent</a> <a href="/tags/Config-Server/" style="font-size: 10px;">Config Server</a> <a href="/tags/Cookie和动态路由/" style="font-size: 10px;">Cookie和动态路由</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Eureka/" style="font-size: 10px;">Eureka</a> <a href="/tags/Executor/" style="font-size: 10px;">Executor</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/Hashtable/" style="font-size: 10px;">Hashtable</a> <a href="/tags/Hystrix/" style="font-size: 10px;">Hystrix</a> <a href="/tags/IOC/" style="font-size: 10px;">IOC</a> <a href="/tags/IO机制/" style="font-size: 10px;">IO机制</a> <a href="/tags/InnoDB/" style="font-size: 10px;">InnoDB</a> <a href="/tags/JUC包的梳理/" style="font-size: 10px;">JUC包的梳理</a> <a href="/tags/JVM内存结构模型/" style="font-size: 10px;">JVM内存结构模型</a> <a href="/tags/Java特性/" style="font-size: 10px;">Java特性</a> <a href="/tags/List/" style="font-size: 10px;">List</a> <a href="/tags/MyISAM/" style="font-size: 10px;">MyISAM</a> <a href="/tags/OSI七层模型/" style="font-size: 10px;">OSI七层模型</a> <a href="/tags/RDB/" style="font-size: 10px;">RDB</a> <a href="/tags/RTO/" style="font-size: 10px;">RTO</a> <a href="/tags/RTT/" style="font-size: 10px;">RTT</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Set/" style="font-size: 10px;">Set</a> <a href="/tags/Spring-Cliud-Stream/" style="font-size: 10px;">Spring Cliud Stream</a> <a href="/tags/Spring-Cloud-Bus/" style="font-size: 10px;">Spring Cloud Bus</a> <a href="/tags/Spring-Cloud-Sleuth/" style="font-size: 10px;">Spring Cloud Sleuth</a> <a href="/tags/TCP的三次握手/" style="font-size: 10px;">TCP的三次握手</a> <a href="/tags/TCP的四次挥手/" style="font-size: 10px;">TCP的四次挥手</a> <a href="/tags/Thread和Runnable/" style="font-size: 10px;">Thread和Runnable</a> <a href="/tags/UDP/" style="font-size: 10px;">UDP</a> <a href="/tags/Zipkin/" style="font-size: 10px;">Zipkin</a> <a href="/tags/Zuul/" style="font-size: 10px;">Zuul</a> <a href="/tags/interrupt/" style="font-size: 10px;">interrupt</a> <a href="/tags/lombok/" style="font-size: 10px;">lombok</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/notify/" style="font-size: 10px;">notify</a> <a href="/tags/sql调优/" style="font-size: 10px;">sql调优</a> <a href="/tags/start和run/" style="font-size: 10px;">start和run</a> <a href="/tags/yield/" style="font-size: 10px;">yield</a> <a href="/tags/代理模式/" style="font-size: 10px;">代理模式</a> <a href="/tags/分布式锁/" style="font-size: 10px;">分布式锁</a> <a href="/tags/单例模式/" style="font-size: 10px;">单例模式</a> <a href="/tags/反射/" style="font-size: 10px;">反射</a> <a href="/tags/回收算法/" style="font-size: 10px;">回收算法</a> <a href="/tags/多路I-O复用模型/" style="font-size: 10px;">多路I/O复用模型</a> <a href="/tags/密集索引/" style="font-size: 10px;">密集索引</a> <a href="/tags/工厂模式/" style="font-size: 10px;">工厂模式</a> <a href="/tags/平台无关性/" style="font-size: 10px;">平台无关性</a> <a href="/tags/并发容器/" style="font-size: 10px;">并发容器</a> <a href="/tags/异常/" style="font-size: 10px;">异常</a> <a href="/tags/异步队列/" style="font-size: 10px;">异步队列</a> <a href="/tags/当前读/" style="font-size: 10px;">当前读</a> <a href="/tags/快照读/" style="font-size: 10px;">快照读</a> <a href="/tags/数据库事务/" style="font-size: 10px;">数据库事务</a> <a href="/tags/数据库架构/" style="font-size: 10px;">数据库架构</a> <a href="/tags/新生代垃圾收集器/" style="font-size: 10px;">新生代垃圾收集器</a> <a href="/tags/日志框架/" style="font-size: 10px;">日志框架</a> <a href="/tags/服务容错/" style="font-size: 10px;">服务容错</a> <a href="/tags/服务网关/" style="font-size: 10px;">服务网关</a> <a href="/tags/标记算法/" style="font-size: 10px;">标记算法</a> <a href="/tags/滑动窗口/" style="font-size: 10px;">滑动窗口</a> <a href="/tags/稀疏索引/" style="font-size: 10px;">稀疏索引</a> <a href="/tags/类的装载/" style="font-size: 10px;">类的装载</a> <a href="/tags/索引/" style="font-size: 15px;">索引</a> <a href="/tags/索引数据结构/" style="font-size: 10px;">索引数据结构</a> <a href="/tags/线程共享/" style="font-size: 10px;">线程共享</a> <a href="/tags/线程独占/" style="font-size: 10px;">线程独占</a> <a href="/tags/老年代垃圾收集器/" style="font-size: 10px;">老年代垃圾收集器</a> <a href="/tags/语法/" style="font-size: 10px;">语法</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/进程和线程/" style="font-size: 10px;">进程和线程</a> <a href="/tags/鉴权/" style="font-size: 10px;">鉴权</a> <a href="/tags/链路监控/" style="font-size: 10px;">链路监控</a> <a href="/tags/锁模块/" style="font-size: 20px;">锁模块</a> <a href="/tags/限流/" style="font-size: 10px;">限流</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">25</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>

    <div>
	<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=22805088&auto=0&height=66"></iframe>
  </div>
  </div>


  
</aside>

        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2020 Contunued Story All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
  </div>
</footer>


<!-- min height -->
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
      var headerblur = document.getElementById("header-blur");
      headerblur.style.minHeight = window.getComputedStyle(document.getElementById("allheader"), null).height;
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true,"scale":0.5},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
