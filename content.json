{"meta":{"title":"Contunued Story","subtitle":null,"description":"Like a bird in the sky","author":"zero","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2019-04-22T06:35:58.000Z","updated":"2019-10-12T14:07:18.670Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"有一个夜晚我烧毁了所有的记忆 从此我的梦就透明了 有一个早晨我扔掉了所有的昨天 从此我的脚步就轻盈了"},{"title":"分类","date":"2019-04-22T06:35:02.000Z","updated":"2019-10-11T03:35:44.717Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-22T06:35:49.000Z","updated":"2019-10-11T03:35:08.726Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java多线程与并发-原理","slug":"Java多线程与并发-原理","date":"2019-11-06T09:26:44.000Z","updated":"2019-11-06T09:29:57.258Z","comments":true,"path":"2019/11/06/Java多线程与并发-原理/","link":"","permalink":"http://yoursite.com/2019/11/06/Java多线程与并发-原理/","excerpt":"","text":"synchronized","categories":[{"name":"Java多线程与并发","slug":"Java多线程与并发","permalink":"http://yoursite.com/categories/Java多线程与并发/"}],"tags":[]},{"title":"Java框架-Spring","slug":"Java框架-Spring","date":"2019-11-05T14:46:40.000Z","updated":"2019-11-06T09:11:27.631Z","comments":true,"path":"2019/11/05/Java框架-Spring/","link":"","permalink":"http://yoursite.com/2019/11/05/Java框架-Spring/","excerpt":"","text":"IOC原理IOC（Inversion of Control）：控制反转Spring Core最核心部分IOC是一种思想，实现手段：依赖注入（Dependency Injection） 依赖注入把底层类作为参数传递给上层类，实现上层对下层的“控制” 依赖注入的方式 Setter Interface Constructor Annotation 依赖倒置原则、IOC、DI、IOC容器的关系 依赖倒置原则是一种思想，高层模块不应该依赖底层模块；有了依赖倒置原则才有了IOC的思路；实现IOC的思路又需要依赖注入的支撑；Spring的框架基于IOC提出了容器的概念，对于IOC来说最重要的就是容器了，容器管理着bean的生命周期，控制着bean的依赖注入。 IOC容器的优势当使用的时候，IOC容器在内部已经完成对象，调用者只需要调用即可！如图蓝色部分全部是由IOC容器完成！ IOC的应用实际应用 读取应用程序提供的Bean配置信息，并在Spring容器中生成一份Bean注册表。 根据生成的Bean注册表通过反射机制实例化Bean，并装配好Bean之间的依赖关系。 将生成的Bean实例对象放入Spring容器中。 Spring IOC支持的功能： 依赖注入 依赖检查 自动装配 支持集合 指定初始化方法和销毁方法 支持回调方法 Spring IOC容器的核心接口 BeanFactory ApplicationContext BeanFactory：Spring框架最核心的接口 提供IOC的配置机制 包含Bean的各种定义，便于实例化Bean 建立Bean之间的依赖关系 Bean生命周期的控制 ApplicationContext的功能（继承多个接口） BeanFactory:能够管理、装配Bean ResourcePatternResolver:能够加载资源文件 MessageSource:能够实现国际化功能 ApplicationEventPublisher:能够注册监听器，实现监听机制 Spring里面几个核心的接口和类 BeanDefinition主要是用来描述Bean的定义 BeanDefinitionRegistry提供向容器注册BeanDefinition对象的方法 refresh 方法 为IOC容器以及Bean的生命周期管理提供条件 刷新Spring上下文信息，定义Spring上下文加载流程 getBean 方法getBean方法的代码逻辑 转换beanName 从缓存中加载实例 实例化Bean 检测parentBeanFactory 初始化依赖的Bean 创建Bean Spring Bean的实例 singleton:Spring的默认作用域，容器里拥有唯一的Bean实例 prototype:针对每个getBean请求，容器都会创建一个Bean实例 request:为每个Httpp请求创建一个Bean实例 session：会为每个session创建一个Bean实例 globlaSession:会为每个全局Http Session创建一个Bean实例，该作用域仅对Portlet有效 创建过程 销毁过程 若实现了DisposableBean接口，则会调用destroy方法 若配置了destry-method属性，则会调用其配置的销毁方法 Spring AOP关注点分离：不同的问题交给不同的部分去解决 面向切面变成AOP正是此种技术的体现 通用代码的实现，对应的就是所谓的切面（Aspect） 业务功能代码和切面代码分开后，架构将变得高内聚低耦合 确保功能的完整性：切面最终需要被合并到业务中（Weave） AOP的三种织入方式 编译时织入：需要特殊的Java编译器，AspectJ 类加载时织入：需要特殊的Java编译器，如AspectJ和AspectWerkz 运行时织入：Spring采用的方式，通过动态代理的方式，实现简单 AOP主要名词概念 Aspect:通用功能代码的实现，切面 Target:被织入Aspect的对象 Join Point：可以作为切入点的机会，所有的方法都可以作为切入点 Pointcut:Aspect实际被应用在的Join Point，支持正则 Advice:类里的方法以及这个方法如何织入到目标方法的方式 Weaving:Aop的实现过程 Advice的种类 前置通知（Before） 后置通知（AfterReturning） 异常通知（AfterThrowing） 最终通知（After） 环绕通知（Around） AOP的实现：JdkProxy和Cglib 由AopProxyFactory根据AdvisedSupport对象配置来决定 默认策略如果目标是接口，则用JDKProxy来实现，否则用后者 JDKProxy的核心：InvocationHandler接口和Proxy类 Cglib:以集成的方式动态生成目标类的代理 JDKProxy:通过Java的内部反射机制实现 Cglib:借助ASM实现 反射机制在生成类的过程中比较高效 ASM在生成类之后的执行过程中比较高效 代理模式：接口+真实实现类+代理类例子： 123public interface Payment&#123; void pay();&#125; 12345678public RealPayment implements Payment&#123; @Override public void pay()&#123; System.out.println(&quot;作为用户我只关心支付&quot;) &#125;&#125; 12345678910111213141516public AliPay implements Payment&#123; private Payment payment; public AliPay(Payment payment) public void beforePay()&#123; System.out.println(&quot;从招行取款&quot;) &#125; @Override public void pay()&#123; beforePay()； payment.pay(); afterPay(); &#125; public void afterPay()&#123; System.out.println(&quot;支付给慕课网&quot;) &#125;&#125; 12Payment proxy = new AliPay(new RealPayment);proxy.pay(); Spring里的代理模式的实现 真实实现类的逻辑包含在了getBean方法里 getBean方法返回的实际上是Proxy实例 Proxy实例是Spring采用JDK Proxy或CGLIB动态生成的 Spring事务的相关问题 ACID 隔离级别 事务传播","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"IOC","slug":"IOC","permalink":"http://yoursite.com/tags/IOC/"},{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"}]},{"title":"Java多线程与并发","slug":"Java多线程与并发","date":"2019-11-05T03:19:48.000Z","updated":"2019-11-07T03:38:42.369Z","comments":true,"path":"2019/11/05/Java多线程与并发/","link":"","permalink":"http://yoursite.com/2019/11/05/Java多线程与并发/","excerpt":"","text":"进程和线程的区别进程和线程的由来 串行：初期的计算机智能执行任务，并且需要长时间等待用户输入 批处理：预先将用户的指令集中成清单，批量串行处理用户指令，仍然无法并发执行 进程：进程独占内存空间，保存各自运行的状态，互不干扰可以相互切换，为并发处理任务提供了可能 线程：共享进程的内存资源，相互间切换更快速，支持更细粒度的任务控制，使进程内的子任务得以并发执行 进程是资源分配的最小单位，线程是CPU调度的最小单位 所有与进程相关的资源都被记录在PCB中 进程是抢占处理机的调度单位；线程属于某个进程，共享其资源 线程只由堆栈寄存器、程序计数器和TCB组成 进程和线程的区别 线程不能看做独立应用，而进程可以看做独立应用 进程有独立的地址空间，相互不影响，线程只是进程不同的执行路径 线程没有独立的地址空间，多进程的程序比多线程程序健壮 进程的切换比线程的切换开销大 进程和线程的关系 Java对操作系统提供的功能进行封装，包括进程和线程 运行一个程序会产生一个进程，进程包含至少一个线程 每个进程对应一个JVM实例，多个线程共享JVM里的堆 Java采用单线程的编程模型，程序会自动创建主线程 主线程可以创建子线程，原则上要后于子线程完成执行 线程start和run方法的区别start（）方法回去调用JVM的StartThread的方法，去创建一个新的子线程，并通过ThreadRun方法去调用run方法 调用start方法会创建一个新的子线程 run方法只是Thread的一个普通方法的调用 Thread和Runnable是什么关系 Thread是实现了Runnabela接口的类，使得run支持多线程 因类的单一继承原则，推荐使用Runnable接口例子1234567891011121314151617181920212223//Thread的使用public class MyThread extends Thread &#123; private String name; public MyThread(String name)&#123; this.name = name; &#125; @Override public void run()&#123; for(int i = 0 ; i &lt; 10 ; i ++)&#123; System.out.println(&quot;Thread start : &quot; + this.name + &quot;,i= &quot; + i); &#125; &#125;&#125;//测试类 public static void main(String[] args) &#123; MyThread mt1 = new MyThread(&quot;Thread1&quot;); MyThread mt2 = new MyThread(&quot;Thread2&quot;); MyThread mt3 = new MyThread(&quot;Thread3&quot;); mt1.start(); mt2.start(); mt3.start(); &#125; 12345678910111213141516171819202122232425//Runable的使用public class MyRunnable implements Runnable &#123; private String name; public MyRunnable(String name)&#123; this.name = name; &#125; @Override public void run()&#123; for(int i = 0 ; i &lt; 10 ; i ++)&#123; System.out.println(&quot;Thread start : &quot; + this.name + &quot;,i= &quot; + i); &#125; &#125;//测试类 public static void main(String[] args) throws InterruptedException &#123; MyRunnable mr1 = new MyRunnable(&quot;Runnable1&quot;); MyRunnable mr2 = new MyRunnable(&quot;Runnable2&quot;); MyRunnable mr3 = new MyRunnable(&quot;Runnable3&quot;); Thread t1 = new Thread(mr1); Thread t2 = new Thread(mr2); Thread t3 = new Thread(mr3); t1.start(); t2.start(); t3.start(); &#125; 如何实现处理线程的返回值如何给run方法传参 构造函数传参 成员变量传参 回调函数传参 如何实现处理线程的返回值 主线程等待法：让主线程循环等待，直到目标子线程返回值 使用Thread类的join()阻塞当前线程以等待子线程处理完毕 通过Callable接口实现：通过FutureTask Or 线程池获取 代码实现： 123456789101112131415161718192021222324public class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception&#123; String value=&quot;test&quot;; System.out.println(&quot;Ready to work&quot;); Thread.currentThread().sleep(5000); System.out.println(&quot;task done&quot;); return value; &#125;&#125;public class FutureTaskDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask&lt;String&gt; task = new FutureTask&lt;String&gt;(new MyCallable()); new Thread(task).start(); if(!task.isDone())&#123; System.out.println(&quot;task has not finished, please wait!&quot;); &#125; System.out.println(&quot;task return: &quot; + task.get()); &#125;&#125; 线程的状态六个状态线程的六个状态 新建（New）：创建后尚未启动的线程的状态 运行（Runnable）：包含Running和Ready，处于Running状态的线程位于可运行线程中，等待被线程调度选中，获取CPU的使用权；处于Ready状态的线程位于线程池中，等待被线程调度选中，获取CPU的使用权，Ready状态的线程在获取CPU时间后，就会变成Running状态的线程 无限期等待（Waiting）：不会被分配CPU执行时间，需要显示被唤醒，即：1）没有设置Timeout参数的Object.wait方法。2）没有设置Timeout参数的Thread.join方法。3）LockSupport方法 限期等待（Timed Waiting）：在一定时间后会由系统自动唤醒。以下情况会造成限期等待：1）Thread.sleep（）方法2）设置了Timeout参数的Object.wait（）方法3）设置了Timeout参数的Thread.join（）方法4）LockSupport.parkNanos（）方法5）LockSupport.parkUntil（）方法 阻塞状态（Blocked）：等待获取排它锁 结束（Terminated）：已终止线程的状态，线程已经结束执行 sleep 和 wait的区别基本的差别sleep是Thread的方法，wait是Object类中定义的方法sleep ()在任何地方都可以使用wait()方法只能在synchronized方法或synchronized块中使用最本质的区别Thread.sleep只会让出cpu,不会导致锁行为的改变Object.wait不仅让出cpu,也会释放锁例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.interview.javabasic.thread;public class WaitSleepDemo &#123; public static void main(String[] args) &#123; final Object lock = new Object(); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;thread A is waiting to get lock&quot;); synchronized (lock)&#123; try &#123; System.out.println(&quot;thread A get lock&quot;); Thread.sleep(20); System.out.println(&quot;thread A do wait method&quot;); lock.wait(); System.out.println(&quot;thread A is done&quot;); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); try&#123; Thread.sleep(10); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;thread B is waiting to get lock&quot;); synchronized (lock)&#123; try &#123; System.out.println(&quot;thread B get lock&quot;); System.out.println(&quot;thread B is sleeping 10 ms&quot;); Thread.sleep(10); Thread.sleep(2000); System.out.println(&quot;thread B is done&quot;); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; notify和notifyall的区别两个概念 锁池 entryList ：假设线程A已经拥有了某个对象（不是类）的锁，而其它线程B,C想要调用这个对象的synchronized方法（或者块），由于B、C线程在进入对象的synchronized方法（或者块）之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前被线程A锁占有，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池 等待池 WaitList：假设线程A调用了某个对象的wait方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁 区别： notifyAll 会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会 notify 只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会 yield关于 Thread.yield() 提示线程调度器表示当前线程可以让出 CPU， 但是调度器可能选择忽略 yield 不会改变当前同步锁的状态 interrupt 函数已经被抛弃的方法 stop（） suspend（）和resunme（）原因：暴力中断线程，如A调用B的stop去终止B线程，由于A不知道B的运行状态，突然停止将可能导致B的一些清理工作无法完成，stop（）方法执行后会马上释放锁，这可能引发数据不同步的问题 目前使用的方法 调用interrupt（），通知线程应该中断了1）如果线程处于阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常2）如果线程处于正常活动状态，那么会将该线程的中断标记设置为true。被设置中断标志的线程将继续正常运行，不受影响 需要被调用的线程配合中断1）在正常运行任务时，进程检查本线程的中断标志位，如果被设置了中断标志就自行停止线程2）如果线程处于正常活动状态，那么会将该线程的终端标记设置为true。被设置中断标志的线程将继续正常运行，不受影响 线程状态以及线程状态之间的转换","categories":[{"name":"Java多线程与并发","slug":"Java多线程与并发","permalink":"http://yoursite.com/categories/Java多线程与并发/"}],"tags":[{"name":"进程和线程","slug":"进程和线程","permalink":"http://yoursite.com/tags/进程和线程/"},{"name":"start和run","slug":"start和run","permalink":"http://yoursite.com/tags/start和run/"},{"name":"Thread和Runnable","slug":"Thread和Runnable","permalink":"http://yoursite.com/tags/Thread和Runnable/"},{"name":"线程状态","slug":"线程状态","permalink":"http://yoursite.com/tags/线程状态/"},{"name":"sleep和wait","slug":"sleep和wait","permalink":"http://yoursite.com/tags/sleep和wait/"},{"name":"notify和notifyall","slug":"notify和notifyall","permalink":"http://yoursite.com/tags/notify和notifyall/"},{"name":"yield","slug":"yield","permalink":"http://yoursite.com/tags/yield/"},{"name":"interrupt","slug":"interrupt","permalink":"http://yoursite.com/tags/interrupt/"}]},{"title":"Java垃圾回收之垃圾回收器","slug":"Java垃圾回收之垃圾回收器","date":"2019-11-02T15:25:09.000Z","updated":"2019-11-05T02:58:10.685Z","comments":true,"path":"2019/11/02/Java垃圾回收之垃圾回收器/","link":"","permalink":"http://yoursite.com/2019/11/02/Java垃圾回收之垃圾回收器/","excerpt":"","text":"前置概念Stop-the-World JVM由于要执行GC而停止了应用程序的执行 任何一种GC算法中都会发生 多数GC优化通过减少Stop-the-world发生的时间来提高程序性能 Safepoint 分析过程中对象引用关系不会发生变化的点 产生Safepoint的地方：方法调用；循环跳转；异常跳转 安全点数量得适中 JVM的运行模式 Server:启动较慢,采用的重量级虚拟机，对程序采用了更多的优化；启动稳定后运行速度比Client快 Client:启动较快 垃圾搜集器之间的联系 Serial收集器（-XX:UseSerialGC,复制算法） 单线程收集，进行垃圾收集时必须暂停所有工作线程 简单高效，Client模式下默认的年轻代收集器 ParNew收集器（-XX:+UseParNewGC,复制算法） 多线程收集，进行垃圾收集时必须暂停所有工作线程 单核执行效率不如Serial,在多核下执行才有优势 Parallel Scavenge收集器（-XX:+UseParallelGC,复制算法） 比起管住用户线程停顿时间，更关注系统的吞吐量 在多核模式下执行才有优势，Server模式下默认的年轻代收集器 Serial Old收集器（-XX:UseSerialOldGC,标记-整理算法） 单线程收集，进行垃圾收集时必须暂停所有工作线程 简单高效，Client模式下默认的老年代收集器 Parllel Old收集器（-XX:+UseParallelOldGC,标记-整理算法） 多线程收集，进行垃圾收集时必须暂停所有工作线程 单核执行效率不如Serial,在多核下执行才有优势 CMS收集器（-XX:+UseConcMarkSweepGC,标记-清除算法） 初始标记：stop-the-world 并发标记：并发追溯标记，程序不会停顿 并发预清理：查找执行并发编辑阶段从年轻代晋升到老年代的对象 重新标记：暂停虚拟机，扫描CMS堆中剩余对象 并发清理：清理垃圾对象，程序不会停顿 并发重置：重置CMS收集器的数据结构 G1收集器（-XX:+UseG1GC,复制+标记-整理算法）Garbage Firlst收集器的特点： 并发和并行，使用多个cup缩短stop-the-world的时间，与用户线程并发执行 分代收集，独立管理整个堆 空间整合，解决内存碎片 可预测的停顿 Garbage First收集器： 将整个堆内存划分为多个大小相等的Region 年轻代和老年代不再物理隔离 问题整理：Object的finalize()方法的作用是否与C++的解析函数作用相同 与C++的析构函数不同，析构函数调用确定，而它的是不确定的 将未被引用的对象放置于F-Queue队列 方法执行随时可能被终止 给予对象最后一次重生机会Java中的强引用，软引用，弱引用，虚引用有什么用 强引用（Strong Reference） 最普遍的引用：Object obj = new Object() 抛出OutOfMemoryError终止程序也不会回收具有强引用的对象 通过将对象设置为null来弱化引用，使其被回收 软引用（Soft Reference） 对象处在有用但非必须的状态 只有当内存空间不足时，GC会回收该引用的内存 可以用来实现高速缓存 12Stirng str = new String(&quot;abc&quot;);//强引用SoftRefence&lt;String&gt;softRef = new SoftRefence&lt;String&gt;(str);//弱引用 弱引用（Weak Reference） 非必须的对象，比软引用更弱一些 GC时会被回收 被回收的概率也不大，因为GC线程优先级比较低 适用于引用偶尔被使用且不影响垃圾收集的对象 虚引用（Phantom Reference） 不会决定对象的生命周期 任何时候都可能被垃圾收集器回收 跟踪对象被垃圾收集器回收的活动，起哨兵作用 必须和引用队列ReferenceQueue联合使用 引用队列（ReferenceQueue） 无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达 存储关联的企鹅杯GC的软引用，弱引用以及虚引用","categories":[{"name":"GC相关","slug":"GC相关","permalink":"http://yoursite.com/categories/GC相关/"}],"tags":[{"name":"新生代垃圾收集器","slug":"新生代垃圾收集器","permalink":"http://yoursite.com/tags/新生代垃圾收集器/"},{"name":"老年代垃圾收集器","slug":"老年代垃圾收集器","permalink":"http://yoursite.com/tags/老年代垃圾收集器/"}]},{"title":"Java垃圾回收之回收算法","slug":"Java垃圾回收之回收算法","date":"2019-11-02T07:57:27.000Z","updated":"2019-11-02T15:10:44.798Z","comments":true,"path":"2019/11/02/Java垃圾回收之回收算法/","link":"","permalink":"http://yoursite.com/2019/11/02/Java垃圾回收之回收算法/","excerpt":"","text":"标记-清除算法（Mark and Sweep） 标记：从跟集合进行扫描，对存活的对象进行标记 清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存 缺点：由于标记清除不需要进行对象的移动，并且仅对不存活的对象进行处理。会产生大量不连续的内存碎片。 复制算法（Coping） 分为对象面和空闲面 对象在对象面上创建 对象面上的内存不足时，存活的对象被从对象面复制到空闲面 将对象面所有对象内存清除 优点 解决碎片化问题 顺序分配内存，简单高效 适用于对象存活率低的场景（年轻代） 标记-整理算法（Compacting） 标记：从根集合进行扫描，对存货的对象进行标记 清除：移动所有存活的对象，切按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收 优点 避免内存的不连续行 不用设置两块内存互换 适用于对象存活率高的场景（老年代） 分代收集算法（Generational Collector） 垃圾回收算法的组合拳 按照对象生命周期的不同划分区域以采取不同的垃圾回收算法 目的：提高JVM的回收效率 GC的分类 Minor GC:发生在年轻中的垃圾收集动作，采用复制算法；年轻代是所有Java对象出生的地方 Full GC:与老年代相关 年轻代：尽可能快速地收集掉那些生命周期短的对象 Eden区（刚创建的对象） 两个Survivor区（幸存者区）新生代占用1/3堆空间，其中Eden 8/10, from1/10 ,to 1/10老年代 2/3堆空间 年轻代垃圾回收的过程： 对象创建在Eden区，当Eden区满了之后会触发一次Minor GC，把标记为存活的对象复制到Survivor0中，清理所有使用过的Eden区域，存活对象年龄+1； 当Eden区再次被填满，触发回Minor GC，会把Eden区和survivor0区中标记为存活的对象都复制到survivor1中，Eden和Survivio区域将会被清空，周而复始 当对象达到一定年龄（默认15岁），会成为老年代；对于一些较大的对象，年轻代无法装下，会直接进入老年代 对象如何晋升到老年代？ 经历一定Minor次数依然存活的对象 Survivor区中存放不下的对象 新生成的大对象（-XX:+PretenuerSizeThreshold） 常用的调优参数 XX:SurvivorRatio:Eden和Survivor的比值，默认8：1 XX:NewRatio:老年代和年轻代大小的比例 MaxTenuringThreshold:对象从年轻代晋升到老年代经过GC次数的最大阈值 老年代:存放生命周期较长的对象 标记-清理算法 标记：整理算法 当触发老年代的垃圾回收的时候，会伴随着新生代堆内存的回收，即对整个堆的垃圾回收。 Full GC和Major GC Full GC比Minor GC慢，但执行效率低 触发Full GC的条件 老年代空间不足 永久代空间不足（JDK7以前的版本） CMS GC时出现promotion failed,concurrent mode failure Minor GC晋升到老年代的平均大小大于老年代的剩余空间 调用System.gc() 使用RMI来进行RPC或管的JDK应用，每小时执行1次Full GC","categories":[{"name":"GC相关","slug":"GC相关","permalink":"http://yoursite.com/categories/GC相关/"}],"tags":[{"name":"回收算法","slug":"回收算法","permalink":"http://yoursite.com/tags/回收算法/"}]},{"title":"Java垃圾回收之标记算法","slug":"Java垃圾回收之标记算法","date":"2019-11-02T06:51:55.000Z","updated":"2019-11-02T07:55:50.870Z","comments":true,"path":"2019/11/02/Java垃圾回收之标记算法/","link":"","permalink":"http://yoursite.com/2019/11/02/Java垃圾回收之标记算法/","excerpt":"","text":"对象被判定为垃圾的标准 没有被其他对象引用 如何判断一个对象不被引用？ 引用计数算法 可达性分析算法 引用计数算法：判断对象的引用数量 通过判断对象的引用数量来决定对象是否可以被回收 每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1 任何引用计数为0的对象实例可以被当做垃圾收集 优点：执行效率高，程序执行受影响较小缺点：无法检测出循环引用的情况，导致内存泄漏 可达性分析算法通过判断对象的引用链是否可达来决定对象是否可以被回收 比如方法区中的类静态属性引用的对象，是可以作为GC Root的， 123public class House &#123; public static Area area = new Area(new Street());&#125; 而Area里面有一个复合对象Street 123456public class Area &#123; private Street street; public Area(Street street)&#123; this.street = street; &#125;;&#125; 那么area 这个静态变量实例就是GC Roots，而Street就类似于Object1 2这些，所以通过Area能找到Street那么它就是可达的。 可作为GC Root的对象 虚拟机栈中引用的对象（栈帧中的本地变量表） 方法区中的常量引用的对象 方法区中的类静态属性引用的对象 本地方法栈中JNI(Natie方法)的引用对象 活跃线程的引用对象","categories":[{"name":"GC相关","slug":"GC相关","permalink":"http://yoursite.com/categories/GC相关/"}],"tags":[{"name":"标记算法","slug":"标记算法","permalink":"http://yoursite.com/tags/标记算法/"}]},{"title":"Java的内存模型常见问题","slug":"Java的内存模型常见问题","date":"2019-10-30T14:57:48.000Z","updated":"2019-11-02T04:08:10.939Z","comments":true,"path":"2019/10/30/Java的内存模型常见问题/","link":"","permalink":"http://yoursite.com/2019/10/30/Java的内存模型常见问题/","excerpt":"","text":"JVM三大性能调优参数-Xms -Xmx -Xss的含义 -Xss：规定的每个虚拟机栈（堆栈）的大小。一般情况下，256K足够。此配置将会影响此进程中并发线程数的大小 -Xms：初始java堆的大小，即该进程刚创建出来的时候java堆的大小。 -Xmx：一旦对象容量超过-Xms大小，则将java堆大小扩容至改参数。为防止heap扩容导致内存抖动，影响程序运行稳定性，一般设置成与Xms一样大小 Java内存模型中堆和栈的区别内存分配策略静态存储：编译时确定每个数据目标在运行时的存储空间需求栈式存储：数据区需求在编译时未知，运行时模块入口前确定堆时存储：编译时或运行时模块入口都无法确定，动态分配 Java内存模型中堆和栈的区别联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址管理方式：栈自动释放，堆需要GC空间大小：栈比堆小碎片相关：栈产生的碎片远小于堆分配方式：栈支持静态和动态分配，而堆仅支持动态分配效率：栈的效率比堆高 元空间、堆、线程独占部分间的联系-内存角度 不同JDK版本之间的intern()方法的区别——JDK6 VS JDK6+12Stirng s = new String (&quot;a&quot;);s.intern(); JDK6: 当调用intern 方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中的该字符串的引用。否则，将此字符串对象添加到字符串常量池中，并且返回该字符串对象的引用JDK6+: 当调用intern 方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中的该字符串的引用。否则，如果该字符串对象已经存在于java堆中，则将堆中对此对象的引用添加到字符串常量池中，并且返回该引用；如果堆中不存在，则在池中创建该字符串并返回其引用","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[]},{"title":"Java内存模型","slug":"Java内存模型","date":"2019-10-30T06:01:08.000Z","updated":"2019-11-03T02:20:50.262Z","comments":true,"path":"2019/10/30/Java内存模型/","link":"","permalink":"http://yoursite.com/2019/10/30/Java内存模型/","excerpt":"","text":"内存简介计算机所有程序都是内存中运行的。在程序执行过程中，需要不断的将内存的逻辑地址和物理地址相互映射，找到相关的指令以及数据去执行。作为操作系统进程，java运行时受限于操作系统架构提供的可寻址空间。操作系统架构的可寻址空间由系统位数决定。 32位处理器：2^32的可寻址范围 64位处理器：2^64的可寻址范围地址空间的划分内核空间用户空间 JVM内存模型-JDK8 线程私有：程序计数器、虚拟机栈、本地方法栈 线程共享：MetaSpace、Java堆 程序计数器（Program Counter Register） 程序计数器（逻辑的），是当前线程所执行的字节码的行号指示器。 由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程独立存储，这种内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。 因为只计数，所以不用担心内存泄露的问题 Java虚拟机栈（Stack） 局部变量表：包含方法执行过程中的所有变量操作数栈：入栈、出栈、复制、交换、产生消费变量 递归引发java.lang.StackOverflowError异常 原因：递归层数过多，当线程执行一个方法时就随之创建一个对应的栈帧，并将建立的栈帧压入虚拟机栈中，当方法执行完毕的时候便会当栈帧出栈，因此可知线程当前执行的方法所对应的的栈帧必定位于Java栈的顶部，而我们的递归函数不断去调用自身，每一次方法调用会涉及：第一，每新调用一次方法就会生成一个栈帧第二,它会保存当前方法的栈帧状态将它放到虚拟机栈中第三,栈帧上下文切换的时候会切换到最新的方法栈帧当中，而由于我们每个线程虚拟机栈深度是固定的，递归实现将导致栈的深度增加，每次递归都会往栈里压入一个栈帧，如果超出的最大允许的深度就会报StackOverfolwError 虚拟机栈过多引发java.lang.OutOfMemoryError异常当虚拟机栈可以自动扩展但是无法申请到新的内存空间时就会抛出java.lang.OutOfMemoryError异常例如： 12345678910public void stackLeakByThread()&#123; while(trur)&#123; new Thread()&#123; public void run()&#123; while(true)&#123; &#125; &#125; &#125;.start() &#125;&#125; 本地方法栈 与虚拟机栈相似，主要用于标注了native方法 元空间（MetaSpace）元空间（MetaSpace）与永久代（PermGen）的区别 在8以后使用元空间（使用本地内存）替代永久代（使用jvm内存）在7以后原先位于方法区的字符串常量池被移到堆中元空间和永久代都是用来存储class的相关信息包括class对象的method和field等元空间和永久代均是方法区的实现，方法区只是jvm的规范 MetaSpace相比PermGen的优势 字符串常量池存在永久代中，容易出现性能问题和内存溢出 类和方法的信息大小难以确定，给永久代的大小指定带来困难 永久代会为GC带来不必要的复杂性 方便HotSpot与其它JVM如Jrockit的集成 Java堆（Heap） 对象实例的分配区域 GC管理的主要区域","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"线程独占","slug":"线程独占","permalink":"http://yoursite.com/tags/线程独占/"},{"name":"线程共享","slug":"线程共享","permalink":"http://yoursite.com/tags/线程共享/"}]},{"title":"谈谈ClassLoader","slug":"谈谈ClassLoader","date":"2019-10-26T03:40:31.000Z","updated":"2019-10-30T05:58:23.913Z","comments":true,"path":"2019/10/26/谈谈ClassLoader/","link":"","permalink":"http://yoursite.com/2019/10/26/谈谈ClassLoader/","excerpt":"","text":"类从编译到执行的过程 编译器将Robot.java源文件编译为Robot.class字节码文件 ClassLoader将字节码转化为jvm中的Class对象 JVM利用Class对象实例化为Robot对象 谈谈ClassLoaderClassLoader 的种类 BootStrapClassLoader:C++编写，加载核心库 java.* ExtClassLoader:Java编写，加载扩展库javaa.* AppClassLoader:Java编写，加载程序所在目录 自定义ClassLoader:Java编写，定制化加载 ClassLoader的作用在Java中有些非常重要的作用，ClassLoader主要工作在Class装载的加载阶段，主要作用是从系统外部获得Class二进制数据流。它是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接，初始化工作 ClassLoader双亲委派机制 自底而上检查类是否已经加载Custom ClassLoader–App ClassLoader–Extension ClassLoader–BootStrap ClassLoader 自上而下尝试加载类BootStrap:加载 jre\\lib\\rt.jar 或者 Xbootclasspath选项指定的jar包Extension:加载 jre\\lib\\ext*.jar 或者 Djava.ext.dirs指定目录下的jar包App: 加载ClassPath 或者 Djava.class.path所指定的目录下的类和jar包 为什么使用双亲委派机制 避免多份同样字节码的加载 类的装载过程 加载：通过ClassLoader加载class文件字节码生成Class对象 链接： 校验：检查加载的class的正确性和安全性 准备：为类变量分配存储空间并设置类变量初始值 解析：JVM将常量池内的符号引用转换为直接引用 初始化：执行类变量赋值和静态代码块loadClass和forName的区别Class.forName是类加载到初始化的步骤Classloader.loadClass是刚执行完加载class Class.forName已完成初始化，那为什么还要用LoadClass呢？LoadClass在springIOC中资源加载器获取要读入的资源的时候，即读取一些bean的配置文件的时候，如果是以classPath方式来加载的话 就需要使用Classload.loadClass来加载，之所以这样做是和springIOC的lazy-loading（懒加载）有关，springIOC为了加快初始化速度因此大量使用延迟加载技术而使用ClassLoad不需要执行类中的初始化代码（static）步骤和连接步骤，这样子做可以加快加载速度 ，把类的初始化工作留到实际使用到这个类的时候才去做.","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"ClassLoader","slug":"ClassLoader","permalink":"http://yoursite.com/tags/ClassLoader/"},{"name":"类的装载","slug":"类的装载","permalink":"http://yoursite.com/tags/类的装载/"}]},{"title":"JVM如何加载class文件","slug":"JVM如何加载class文件","date":"2019-10-26T01:53:49.000Z","updated":"2019-10-26T03:29:53.900Z","comments":true,"path":"2019/10/26/JVM如何加载class文件/","link":"","permalink":"http://yoursite.com/2019/10/26/JVM如何加载class文件/","excerpt":"","text":"Java虚拟机Java虚拟机：抽象化的计算机，通过在实际的计算机上个仿真模拟计算机功能来实现的，有自己完善的硬件架构：处理器，堆栈，寄存器等，还具有相应的指令系统，jvm 屏蔽了与具体操作系统平台相关的信息，使得java程序只需要生成在java虚拟机上运行的字节码，就可以在不同平台上不加修改的运行。其中最重要的两点：JVM内存结构模型，GC jvm是内存中的虚拟机，jvm的存储就是内存，所有写的 类，常量，变量，方法都在内存中这决定着程序的健壮和高效 Class Loader ： 依据特定格式，加载class文件到内存 Runtime Data Area ：JVM内存空间结构模型 Native Interface: 融合不同开发语言的原生库为Java所用 Execution Engine ：对命令进行解析 JVM结构： Class Loader, Runtime Data Area, Execution Engine, Native Interface Java反射机制JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 写一个反射的例子Robot.java 1234567891011package com.interview.javabasic.reflectpublic class Robot&#123; private String name; public void sayHi(String helloSentence)&#123; System.out.println(helloSentence + &quot;&quot; + name) &#125; private String throwHello(String tag)&#123; return &quot;Hello&quot; + tag; &#125;&#125; ReflectSample.java 1234567891011121314151617181920public static void main(String[] args)&#123; //先获取Robot类，需要全路径 Class rc = Class.forNam(&quot;com.interview.javabasic.reflect.Robot&quot;) //创建实例,需要强转，newInstance返回的是泛型 Robot r = (Robot)rc.newInstance(); System.out.println(&quot;Class name is &quot; + rc.getName()); //通过反射获取私有方法,throwHello接收一个String类型的参数 Method getHello = rc.getDeclaredMethod( name: &quot;throwHello&quot;,String.class)； getHello.setAccessible(true); //需要传入对象实例，和方法参数 Object str = getHello.invoke(r,&quot;Bob&quot;); System.out.println(&quot;getHello result is &quot; + str); //第二种获取方法获取方法 Method sayHi = rc.getMethod( name: &quot;sayHi&quot;,String.class)； sayHi.invoke(r,&quot;Welcome&quot;); //获取私有类型的Filed Filed name = rc.getDeclaredField(name: &quot;name&quot;); name.setAccessible(true); name.set(r,&quot;Alice&quot;)&#125; Metohd:newInstance()方法返回的是泛型。getDeclaredMethod可以获得该类所有的方法，除去继承和实现了接口的方法。如果是私有的方法，必须使用setAccessible(true)方法。getMethod可以获得该类所有的公有方法，还有所继承的以及实现了接口的方法。 Field:getDeclaredField获取属性如果是私有属性也要设置setAccessible(true)","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"JVM内存结构模型","slug":"JVM内存结构模型","permalink":"http://yoursite.com/tags/JVM内存结构模型/"},{"name":"反射","slug":"反射","permalink":"http://yoursite.com/tags/反射/"}]},{"title":"谈谈我对Java的理解","slug":"谈谈我对Java的理解","date":"2019-10-25T08:23:12.000Z","updated":"2019-11-03T03:00:25.964Z","comments":true,"path":"2019/10/25/谈谈我对Java的理解/","link":"","permalink":"http://yoursite.com/2019/10/25/谈谈我对Java的理解/","excerpt":"","text":"谈谈我对Java的理解从以下几个点进行扩展 平台无关性：一次编译到处运行GC垃圾回收：不用手动释放内存语言特性：泛型、lamda、反射面向对象：封装、继承、多态类库：自带的集合和并发库异常处理 Compile Once,Run Anywhere如何实现（如何实现平台无关的）？编译时：javac运行时:java.java文件首先经过javac编译生成字节码。将字节码保存在.class文件中。.class文件是跨平台的基础。再由不同平台的JVM进行解析，java语言在不同的平台上运行时不需要进行重新编译，java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令。 为什么jvm不直接执行源码，而是将字节码解析成机器码才去执行 每次执行都需要各种检查（语法，句法，语义的检查，每次执行的时候，这些语义分析结果不会被保留下来。因此引入字节码，在每次执行程序是不需要各种校验和补全的） 兼容性，可以将别的语言（groovy,scala）解析成字节码","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"Java特性","slug":"Java特性","permalink":"http://yoursite.com/tags/Java特性/"},{"name":"平台无关性","slug":"平台无关性","permalink":"http://yoursite.com/tags/平台无关性/"}]},{"title":"Linux体系结构","slug":"Linux体系结构","date":"2019-10-21T14:29:34.000Z","updated":"2019-10-25T07:31:47.443Z","comments":true,"path":"2019/10/21/Linux体系结构/","link":"","permalink":"http://yoursite.com/2019/10/21/Linux体系结构/","excerpt":"","text":"Linux 体系结构 体系结构主要分为用户态（用户上层活动）和内核态 内核：本质是一段管理计算机硬件设备的程序 系统调用：内核的访问接口，是一种不能再简化的操作 公用函数库：系统调用的组合拳 Shell：命令解释器，可编程 远程登录终端利用ssh登录远程服务器 安装ssh： 1yum install ssh 启动ssh： 1service sshd start 登录远程服务器： 123ssh -p 50022 my@127.0.0.1输入密码：my@127.0.0.1: -p 后面是端口 my 是服务器用户名 127.0.0.1 是服务器 ip 回车输入密码即可登录 如何查找特定的文件find1语法：find path 【options】 params 作用：在指定目录下查找文件 常用的方式~表示当前用户的目录 1234 find ~ -name &quot;target1.java&quot; :查找精确文件 find ~ -name &quot;target*&quot; :查找精确文件 find ~ -iname &quot;target*&quot; :不区分文件名大小写去查找文件 man find : 更多关于find指令的使用说明 检索文件内容1语法：grep 【options】 pattern file 全称：Global Regular Expression Print作用：在指定目录下查找文件 12例如：查找包含内容&quot;moo&quot; 以target开头的文件grep &quot;moo&quot; target* 管道操作符|可将指令连接起来，前一个指令的输出作为后一个指令的输入 12例如：查找当前用户下以target开头的文件find ~ | grep &quot;target*&quot; 常用的方式123456781.在内容（文件）里面查找包含某字段的文件，并展示出对应行内容grep &apos;partial\\[true\\]&apos; bac-plat-al-data.info.log 2.-o 筛选出符合正则表达式的内容grep -o &apos;engine\\[[0-9a-z]*\\]&apos; 3.-v 过滤掉包含相关字符串的内容grep -v &apos;grep&apos; 对文件内容做统计场景：我想筛选出 partial为true的引擎，并统计日志里出现的次数。当我们发现某个检索引擎的partial为true超过一定次数后，说明该引擎需要从集群中摘掉进行修复； awk1语法：awk [options] &apos;cmd&apos; file 一次读取一行文本，按输入分隔符进行切片，切成多个组成部分 将切片直接保存在内建的变量中，$1,$2,..($0表示行的全部) 支持对单个切片的判断，支持循环判断，默认分隔符为空格 常用的方式12345678打印出第一列和第四列的内容：awk &apos;&#123;print $1,$4&#125;&apos; 文件名筛选出列指定字符的行：awk &apos;$1==&quot;tcp&quot; &amp;&amp; $2==1&#123;print $0&#125;&apos; 文件名打印出表头：awk &apos;($1==&quot;tcp&quot; &amp;&amp; $2==1) || NR==1 &#123;print $0&#125;&apos; 文件名以指定分隔符分割内容：awk -F &quot;,&quot; &apos;&#123;print $2&#125;&apos; 文件名 12Linux 命令 awk 统计：awk &apos;&#123;enginearr[$1]++&#125;END&#123;for (i in enginearr) print i &quot;\\t&quot; enginearr[i]&#125;&apos; enginearr ：自定义的数组，如果第一列$1出现重复就自增1END ：扫描统计结束{for(i in enginearr)}：循环自定义的数组，定义变量 iprint i : 打印 i“\\t” 拼接回车符enginearr[i] : 指定自定义数组 批量替换文本内容sed1语法：sed [option] &apos;sed command&apos; filenae 全名stream editor,流编辑器适合用于对文本的行内容进行处理 常用的方式12345678910111213141.将文件中以Str开头的字符串替换成 String：sed -i &apos;s/^Str/String/&apos; replace.txt2.将末尾的点号转为分号：sed -i &apos;s/\\.$/\\;/&apos; replace.txt3.将所有的&quot;Jack&quot;替换成&quot;me&quot;sed -i &apos;s/Jack/me/g&apos; replace.txt4.删除空行命令sed -i &apos;/^ *$/d&apos; replace.txt5.删除包含特定字符的行：sed -i &apos;/Integer/d&apos; replace.txt 特别指出： 指令中加入 -i 表示修改保存到文件中 替换语法后加入 /g 表示将文件中所有符合条件的内容全部替换，否则只替换一行中第一次匹配到的字符 总结：经常用到的Shell命令 find grep 管道操作符| awk sed","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"Redis集群","slug":"Redis集群","date":"2019-10-21T14:27:28.000Z","updated":"2019-10-21T14:27:28.170Z","comments":true,"path":"2019/10/21/Redis集群/","link":"","permalink":"http://yoursite.com/2019/10/21/Redis集群/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Pipeline及主从同步","slug":"Pipeline及主从同步","date":"2019-10-21T14:27:10.000Z","updated":"2019-10-21T14:27:10.138Z","comments":true,"path":"2019/10/21/Pipeline及主从同步/","link":"","permalink":"http://yoursite.com/2019/10/21/Pipeline及主从同步/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Redis持久化方式","slug":"Redis持久化方式","date":"2019-10-21T14:23:15.000Z","updated":"2019-10-21T14:25:32.283Z","comments":true,"path":"2019/10/21/Redis持久化方式/","link":"","permalink":"http://yoursite.com/2019/10/21/Redis持久化方式/","excerpt":"","text":"RDB(快照)持久化：保存某个时间点的全量数据快照","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"RDB","slug":"RDB","permalink":"http://yoursite.com/tags/RDB/"},{"name":"AOF","slug":"AOF","permalink":"http://yoursite.com/tags/AOF/"}]},{"title":"如何实现异步队列","slug":"如何实现异步队列","date":"2019-10-20T06:55:22.000Z","updated":"2019-10-21T00:51:10.064Z","comments":true,"path":"2019/10/20/如何实现异步队列/","link":"","permalink":"http://yoursite.com/2019/10/20/如何实现异步队列/","excerpt":"","text":"用list作为队列rpush 作为生产者生产消息， lpop 作为消费者消费消息缺点： 没有等待 队列里有值就直接消费弥补：可以通过在应用层引入sleep机制去调用lpop重试； 如果不用 sleep机制 ，可以使用 blpop key[key..] timeout 阻塞直到队列有消息或者超时缺点：一个生产者对应一个消费者 pub/sub 主题订阅模式发送者 pub 发送消息，订阅者 sub 接受消息订阅者可以订阅任意数量的频道缺点： 消息无状态，无法保证可达","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"异步队列","slug":"异步队列","permalink":"http://yoursite.com/tags/异步队列/"}]},{"title":"如何通过Redis实现分布式锁","slug":"如何实现分布式锁","date":"2019-10-18T05:47:11.000Z","updated":"2019-10-18T06:52:06.874Z","comments":true,"path":"2019/10/18/如何实现分布式锁/","link":"","permalink":"http://yoursite.com/2019/10/18/如何实现分布式锁/","excerpt":"","text":"什么是分布式锁分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁的实现 分布式锁需要解决的问题 互斥性：任意时刻只能有一个客户端获取到锁 安全性：锁只能被持有该锁的客户端删除 死锁：获取锁的客户端因为某些原因宕机而未能释放锁，其他客户端再也无法获取到该锁而导致的死锁 容错：当部分Redis节点宕机了之后客户端仍然能够获取锁和释放锁SENTNX key value:如果key不存在，则创建并赋值 时间复杂度 O(1) 返回值：设置成功，返回1；设置失败，返回0 1234get locknx(nil)setnx locknx test(integer)1 setnx 操作是原子性的，初期被用来实现分布式锁；在执行某段代码逻辑的时候先尝试使用setnx对某个key设值，如果设置成功则证明此时没有别的线程在执行该段代码（占用该独占资源），这个时候线程就可以顺利的执行该段代码逻辑，如果设置失败则证明有别的程序或线程占用该资源。当前线程需要等待直至setnx成功 如何解决SETNX长期有效的问题EXPIRE key seconds 设置key的生存时间，当key过期时（生存时间为0），会被自动删除 缺点：原子性得不到满足 12//设置过期时间2秒钟expire locknx 2 伪代码示例： 12345678RedisService redisService = SpringUtils.getBean(RedisService.class)long status = redisService.setnx(key,&quot;1&quot;)if(status == 1)&#123; redisService.expire(key,expire); //执行独占资源逻辑 doOcuppiedWord()&#125; 潜在问题，在setnx后线程挂掉，key将会被一直占用 SET key value [EX seconds][PX milliseconds][NX|XX]ex:设置键的过期时间为单位妙px:设置键的过期时间为单位毫秒NX:只在键不存在时，才对键进行设置操作XX:只在键已经存在时，才对键进行设置操作设置成功返回ok,否则返回nil 1set locktarget 12345 ex 10 nx 大量的key同时过期的注意事项集中过期，由于清除大量的key很耗时，会出现短暂的卡顿现象解决方案：在设置key的过期时间的时候，给每个key加上随机值","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"分布式锁","slug":"分布式锁","permalink":"http://yoursite.com/tags/分布式锁/"}]},{"title":"Redis简介","slug":"Redis简介","date":"2019-10-16T13:13:26.000Z","updated":"2019-10-18T05:54:55.909Z","comments":true,"path":"2019/10/16/Redis简介/","link":"","permalink":"http://yoursite.com/2019/10/16/Redis简介/","excerpt":"","text":"缓存中间件——Memcache和Redis的区别Mecache：代码层次类似Hash 支持简单数据类型 不支持数据持久化存储 不支持主从 不支持分片Redis 数据类型丰富 支持数据磁盘持久化存储 支持主从 支持分片 为什么Redis能这么快100000+QPS(QPS既query per second 每秒内查询次数) 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高 数据结构简单，对数据操作也简单 采用单线程，单线程也能处理高并发请求，想多核也可启动多实例 使用多路I/O 复用模型，非阻塞IO redis 是跑在单线程中的，所有的操作又是按照线性顺序执行的，但是由于读写操作等待用户输入或者输出都是阻塞的，所以io操作在一般情况下往往不能直接返回，这会导致某一文件的io阻塞，进而导致整个进程无法对其他客户端提供服务而io多路复用就是为了解决这个问题的 多路I/O复用模型FD：File Descriptor,文件描述符一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射 Redis采用的I/O多路复用函数：epoll/kqueue/evport/select? 因地制宜 优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现 以时间复杂度为O(n)的select作为保底 基于react设计模式监听I/O事件 Redis常用的数据类型 String:最基本的数据类型，二进制安全 Hash:String 元素组成的字典，适合用于存储对象 List:列表，按照String元素插入顺序排序 Set:String元素组成的无序集合，通过哈希表实现，不允许重复 Sorted-Set:通过分数来为集合中的成员进行从小到大的排序 用于计数的HyperLogLog ,用于支持存储地理信息位置的Geo 从海量数据查询某一固定的前缀key使用keys对线上的业务的影响KEYS pattern：查找所有符合给定模式pattern的key KEYS指令一次性返回所有匹配的key 键的数量过大会使服务器卡顿 KEYS CURSOR [MATCH pattern][COUNT count] 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程 以0作为游标开始一次新的迭代，知道命令返回游标0完成一次游历 不保证每次执行都返回某个给定数量的元素，支持模糊查询 一次返回的数量不可控，只能是大概率符合count参数 12//开始迭代返回以k1开始的key,希望一次返回10个scan 0 match k1* count 10","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"多路I/O复用模型","slug":"多路I-O复用模型","permalink":"http://yoursite.com/tags/多路I-O复用模型/"}]},{"title":"数据库关键语法","slug":"数据库关键语法","date":"2019-10-16T08:29:26.000Z","updated":"2019-10-16T13:09:10.429Z","comments":true,"path":"2019/10/16/数据库关键语法/","link":"","permalink":"http://yoursite.com/2019/10/16/数据库关键语法/","excerpt":"","text":"关键语法 GROUP BY HAVING 统计相关：COUNT,SUM,MAX,MIN,AVG GROUP BY 满足 SELECT子句中列名必须为分组列或者列函数 列函数对于group by子句定义的每个组各返回一个结果 HAVING 通常与GRPUP BY子句一起使用 WHERE过滤行，HAVING过滤组 出现在同一sql的顺序：WHERE&gt;GROUP BY&gt;HAVING","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"InnoDB可重复读隔离级别下如何避免幻读","slug":"InnoDB可重复读隔离级别下如何避免幻读","date":"2019-10-16T07:15:06.000Z","updated":"2019-10-16T08:15:50.399Z","comments":true,"path":"2019/10/16/InnoDB可重复读隔离级别下如何避免幻读/","link":"","permalink":"http://yoursite.com/2019/10/16/InnoDB可重复读隔离级别下如何避免幻读/","excerpt":"","text":"InnoDB可重复读隔离级别下如何避免幻读表象：快照读（非堵塞读） –伪MVCC内在：next-key锁（行锁+gap锁） next-key锁（行锁+gap锁） 行锁 Gap锁 Gap锁Gap的定义：索引字段排序结果的左开右闭区间，例如：1，3，5，7 的Gap为（-∞,1] (1,3] (2,7] (7,+∞]Gap锁的触发条件：使用主键/唯一索引的当前读: where条件精确每一行，只触发行锁 命中部分行，不命中任何一行，触发Gap锁 使用非唯一索引的当前读: 触发Gap锁 不使用索引： 触发Gap锁，并且锁定所有的Gap，相当于锁表","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[]},{"title":"锁模块之当前读和快照读","slug":"锁模块之当前读和快照读","date":"2019-10-16T06:37:29.000Z","updated":"2019-10-16T07:12:33.216Z","comments":true,"path":"2019/10/16/锁模块之当前读和快照读/","link":"","permalink":"http://yoursite.com/2019/10/16/锁模块之当前读和快照读/","excerpt":"","text":"当前读和快照读 当前读：就是加了锁的增删改查语句。读取的是记录的最新版本。读取的时候保证其他事务不能对数据进行修改。 12select ... lock in share mode ,select ... for update update,delete,insert 快照读：不加锁的非阻塞读 ，select RC、RR级别下的InnoDB的非堵塞读（快照读）如何实现 数据行里的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段 DB_TRX_ID：事务ID，标识对本行数据最近一次的更新(增删改) DB_ROLL_PTR：回滚指针， 指向回滚日志undo log的一条记录，一次更新对应一条undo log记录 DB_ROW_ID：新行插入，产生一个自增ID undo日志undo log：回滚日志，存储各个老版本的数据，由undo链串起来 含insert undo log和 update undo log read view：决定当前数据看到的是哪个版本。用来做可见性判断,即我们做快照读select的时候，会针对我们查询的数据，创建出一个read view来决定当前事务能看到那个版本的数据，可能当前最新，也可能是undo log 中某个版本的数据。它遵循一个可见性算法，主要是将要修该的数据的DB_TRX_ID取出来与系统其他活跃事务id作对比，如果大于或等于就通过DB_ROLL_PTR指针取出undo log 上一层的的DB_TRX_ID直到小于这些活跃事务为止。这样保证了我们获取的数据版本是当前可见的最稳定版本。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"锁模块","slug":"锁模块","permalink":"http://yoursite.com/tags/锁模块/"},{"name":"当前读","slug":"当前读","permalink":"http://yoursite.com/tags/当前读/"},{"name":"快照读","slug":"快照读","permalink":"http://yoursite.com/tags/快照读/"}]},{"title":"锁模块之数据事务","slug":"锁模块之数据事务","date":"2019-10-12T08:25:36.000Z","updated":"2019-11-03T08:24:15.578Z","comments":true,"path":"2019/10/12/锁模块之数据事务/","link":"","permalink":"http://yoursite.com/2019/10/12/锁模块之数据事务/","excerpt":"","text":"数据库事务的四大特性ACID 原子性(Athomic) : 事务包含的全部操作要么全部执行，要么全部失败回滚 一致性(Consistency) : 事务应确保数据库的状态从一个一致状态到另一个一致状态(eg:转账问题，A和B一共2000，无论来回怎么转总和还是2000) 隔离性(Isolaton)：一个事务的执行不应该影响其它事务的执行 持久性(Durability)：一个事务的提交代表了它对数据库的修改永久保存在数据库中，当系统发生故障时确保已提交事务的更新不能丢失，确保已提交事务的更新能恢复 事务隔离级别以及各级别下的并发访问问题更新丢失（MySQL所有事务隔离级别在数据库层面上均可避免）事务A对数据进行操作时，事务B也在对同一数据更新操作并完成了提交，然后事务A遇到异常进行回滚导致事务B的更新丢失。 脏读一个事务读到另一个事务未提交的数据。 不可重复读事务A在多次读取同一数据的过程中，事务B对数据进行更新并提交，导致事务A多次读取同一数据时结果不一致。 幻读事务A读取若干行数据，事务B以插入或删除行的方式来修改事务A的结果集。 其中不可重复读与幻读比较相似，不可重复读侧重对同一数据的修改，幻读侧重插入增加或删除数据。事务隔离级别越高，对性能的影响也越大。 事务并发访问引起的问题以及如何避免 更新丢失——mysql所有事务隔离级别在数据库层面上均可避免 脏读——READ-COMMITTED事务隔离级别以上避免 不可重复读——REPEATABLE-READ事务隔离级别以上可避免 幻读——SERIALIZABLE事务隔离级别避免 事务隔离级别 更新丢失 脏读 不可重复度 幻读 未提交读 避免 发生 发生 发生 已提交读 避免 避免 发生 发生 可重复读 避免 避免 避免 发生 串行化 避免 避免 避免 避免","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"锁模块","slug":"锁模块","permalink":"http://yoursite.com/tags/锁模块/"},{"name":"数据库事务","slug":"数据库事务","permalink":"http://yoursite.com/tags/数据库事务/"},{"name":"ACID","slug":"ACID","permalink":"http://yoursite.com/tags/ACID/"}]},{"title":"锁模块MyISAM与InooDB关于锁方面的区别","slug":"锁模块MyISAM与InooDB关于锁方面的区别","date":"2019-10-11T10:42:44.000Z","updated":"2019-11-03T08:12:37.813Z","comments":true,"path":"2019/10/11/锁模块MyISAM与InooDB关于锁方面的区别/","link":"","permalink":"http://yoursite.com/2019/10/11/锁模块MyISAM与InooDB关于锁方面的区别/","excerpt":"","text":"常见问题 MyISAM与InnoDB关于锁方面的区别是什么 数据库事务的四大特性 事务隔离级别以及各级别下的并发访问问题 InnoDB可重复度隔离级别下如何变幻读 RC、RB级别下的InnoDB的非阻塞读如何实现MyISAM与InnoDB关于锁方面的区别 MyISAM默认用的是表级锁，不支持行级锁 ，MyISAM不支持事务 InnoDB默认用的是行级锁 ，也支持表级锁，InnoDB在不走索引的时候用的是表级锁，而sql用到索引的时候用的是行级锁 值得注意的是： MyISAM默认会给select语句上共享锁(读锁) InnoDB默认不会给select语句上共享锁(读锁) 上了共享锁的可以再上共享锁但是不能上排他锁 上了排他锁的不可以再上共享锁和排他锁共享锁和排斥锁的兼容性 X S X 冲突 冲突 S 冲突 兼容 1234#查看session是否为自动提交show variables like &apos;autocommit&apos;;#将session设置为自动提交set autocommit = 1; MyISAM适合的场景 频繁执行全表count语句（有个变量保存了表的行数，可直接读该变量） 对数据进行增删改的频率不高，查询非常频繁（增删改会涉及到锁表操作） 没有事务 InnoDB适合的场景 数据增删改查相当频繁（增删改的时候只是某些行被锁，大多数情况下，避免阻塞） 可靠性要求比较高，要求支持事务 数据库锁的分类 按锁的粒度划分，表级锁，行级锁，页级锁 按锁级别划分，共享锁，排他锁 按加锁方式划分，自动锁（意向锁），显式锁（手工加锁） 按操作划分，DML锁，DDL锁 按使用方式划分，乐观锁，悲观锁","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"锁模块","slug":"锁模块","permalink":"http://yoursite.com/tags/锁模块/"}]},{"title":"索引额外问题之如何调优sql","slug":"索引额外问题之如何调优sql","date":"2019-10-11T06:37:24.000Z","updated":"2019-11-03T07:53:15.459Z","comments":true,"path":"2019/10/11/索引额外问题之如何调优sql/","link":"","permalink":"http://yoursite.com/2019/10/11/索引额外问题之如何调优sql/","excerpt":"","text":"常见问题总结 如何定位并优化慢查询sql 联合索引的最左匹配原则的成因 索引建立的越多越好吗如何定位并优化慢sql大致思路 根据慢日志定位慢sql 12345SHOW VARIABLES LIKE &apos;%quer%&apos;; 查看慢查询是否打开set global slow_query_log =on; 打开慢查询:set global long_query_time=1; 设置慢查询最大时间超过一秒就记录为慢查询 SHOW STATUS LIKE &apos;%slow_queries%&apos;; 查看慢sql条数sudo vim /usr/local/mysql/data/VM_33_68_centos-slow.log; 查看被记录到慢日志里面的日志 使用explain等工具分析sql explain字段 type ： mysql找到数据行的方式index 和 all 是全表扫描 extra：有很多值 Using filesort ，Using temporary 最常的慢的， 修改sql或者尽量让sql走索引 具体走那个索引是mysql查询优化器决定， 要强制制定走某个索引 要加上 force index（primary/其他） 联合索引的最左匹配原则 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询（&gt; , &lt; , between, like ）就停止匹配，比如a=3 and b = 4 and c &gt; 5 and d =6 如果建立（a，b，c，d）顺序的索引，d是用不到索引的，如果建立（a，b，d，c）的索引则可以用到，a、b、d的顺序可以任意调整 =和in可以乱序，比如a=1 and b=2 and c=3建立（a,b,c）索引可以任意顺序，mysql查询优化器会帮你优化成索引可以识别的形式 索引是建立得越多越好吗 数据量小的表不需要建立索引，建立索引会增加额外的索引开销 数据变更需要维护索引，因此更多的索引意味着更多的维护成本 更多的索引也意味着更多的空间","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"sql调优","slug":"sql调优","permalink":"http://yoursite.com/tags/sql调优/"}]},{"title":"密集索引和稀疏索引","slug":"密集索引和稀疏索引","date":"2019-10-11T03:52:34.000Z","updated":"2019-11-03T07:40:26.718Z","comments":true,"path":"2019/10/11/密集索引和稀疏索引/","link":"","permalink":"http://yoursite.com/2019/10/11/密集索引和稀疏索引/","excerpt":"","text":"密集索引和稀疏索引的区别 密集索引文件中的每个搜索码值都对应一个索引值 稀疏索引文件只为索引码的某些值建立索引项 InnoDB 和 MyISAM InnoDB 采用密集索引+稀疏索引,主键索引可以直接找到叶子节点中的数据,辅助键索引需要先找到主键再通过主键B+树找到数据 ,即InnoDB数据和索引是存放在一个文件里的 MyISam 全部采用稀疏索引,根据主键和辅助键的索引都只能找到一个地址信息,要再根据这个地址信息去另外一个文件中寻找数据,即MyISam的索引和数据是分开存放的 表结构都存储在*.frm中MyISAM索引和数据是分开存储的.MYI存储索引.MYD存储数据InnoDB索引和数据是存在一起的.ibd","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"},{"name":"密集索引","slug":"密集索引","permalink":"http://yoursite.com/tags/密集索引/"},{"name":"稀疏索引","slug":"稀疏索引","permalink":"http://yoursite.com/tags/稀疏索引/"},{"name":"InnoDB","slug":"InnoDB","permalink":"http://yoursite.com/tags/InnoDB/"},{"name":"MyISAM","slug":"MyISAM","permalink":"http://yoursite.com/tags/MyISAM/"}]},{"title":"优化你的索引","slug":"优化你的索引","date":"2019-10-10T10:26:36.000Z","updated":"2019-10-11T06:39:33.192Z","comments":true,"path":"2019/10/10/优化你的索引/","link":"","permalink":"http://yoursite.com/2019/10/10/优化你的索引/","excerpt":"","text":"二叉查找树二叉树,(有明显缺陷的数据结构): 如果添加的数据一直在某一侧的时候,就会变成线性而二叉树,查询复杂度会上升,查找效率会大幅度降低 影响数据检索最根本的原因是IO,即数据库文件的读写，也就是将硬盘的数据读到内存中而我们的二叉树在检索深度每次加1后都需要读取一个节点,执行一次IO,效率很低 B-TreeB-TREEB树的定义： 根节点至少包含两个孩子 树中每个节点最多含有m个孩子（ m &gt;= 2） 除根节点和叶节点外，其他每个节点至少有 ceil(m/2)个孩子 所有叶子节点都位于同一层 假设每个非终端节点包含有n个关键字信息，其中 Ki(i=1,…n)为关键字，关键字按顺序排序K(i-1)&lt;Ki 关键字个数n必须满足 : [cell(m/2)-1]&lt;=n&lt;=m-1 非叶子节点的指针：P[1],p[2],….,p[M];其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1],K[i])的子树 B+-TreeB+树定义： 非叶子节点的子树指针和关键字个数相同 非叶子节点的子树指针P[i],指向关键字值[K[i],K[i+1])的子树, 大于等于 K[i] 小于 K[i+1] 非叶子节点仅用来做索引，数据都保存在叶子节点中 所有叶子节点均有一个链指针指向下一个叶子节点 B+Tree更适合用来存储索引 B+ 树的磁盘读写代价更低（程序运行，往往最耗时的操作就是IO，如果IO的次数越少，那么运行也就越快，代价也就越低，非叶子节点结构没有指向关键字对应表记录的指针，只存放索引，因此节点比B树更小） B+ 树的查询效率更加稳定，数据存放在叶节点中，也就意味着每次查询都需要经过从根节点到叶节点的查询路径，时间复杂度味为O(logn)，比较稳定 B+ 树更有利于对数据库的扫描（因为数据只存放在叶节点中，而且有顺序，所以更好的查询数据范围） Hash 索引 hash 命中key 直接定位数据，理论上高于 b-tree b+tree 只能用 = 和 in ，不能范围查询，不能排序，不能组合索引(比较hash值是否相等来查询数据,并不能代表hash值的实际大小) hash值命中同一个存放位置， 效率不稳定，有可能还不如b+ tree（想想线性二叉树）bitmap 索引bitmap位图，适用于字段值只是固定的几个，如男、女，颜色；便于高效统计。Oracle支持位图索引，数据结构了类似B+树。锁很严重，可能因为某行修改都会锁。适合并发较少，统计较多的情况","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"},{"name":"索引数据结构","slug":"索引数据结构","permalink":"http://yoursite.com/tags/索引数据结构/"}]},{"title":"数据库架构","slug":"数据库架构","date":"2019-10-08T14:24:35.000Z","updated":"2019-10-11T01:56:05.417Z","comments":true,"path":"2019/10/08/数据库架构/","link":"","permalink":"http://yoursite.com/2019/10/08/数据库架构/","excerpt":"","text":"如何去设计一个关系型数据库第一部分为存储部分，相当于文件系统，将数据持久化到存储设备中 第二部分为程序实例，对存储进行逻辑上的管理。 程序实例分为8个模块： 存储管理：将数据的逻辑关系转化为物理存储关系。 缓存机制：优化执行效率。 SQL解析：解析SQL语句。 日志管理：记录操作。 权限划分：进行多用户管理。 容灾机制：灾难恢复。 索引管理：优化数据查询效率。 锁管理：使数据库支持高并发。 常见问题 为什么要使用索引 什么样的信息能成为索引 索引的数据结构 密集索引和稀疏索引的区别 为什么要使用索引先说不使用索引情况下的全表扫描: 数据库存储的最小单位是块或者页,是由多行记录组成的。(一个表就是多个块或者多个页)我们把这些块或者页加载进来,然后对每个块或页进行轮训,找到目标返回,类似:要从一本字典的第一页开始查找数据,一页一页的查,如果数据量小还好,数据量大就很慢 所以我们推出索引的概念:也就是引入字典中目录的概念,我们可以通过字典的拼音,部首,进行一层又一层的有条理的查询而这些被另外定义出来的例如:拼音,部首,就可以叫做索引 简单讲就是:为了避免全表扫描,大幅提高查询数据的效率 什么样的信息能成为索引主键、唯一键、普通键 索引的数据结构 生成索引，建立二叉查找树进行二分查找 生成索引，建立B-Tree结构进行查找 生成索引，建立B+-Tree结构进行查找 生成索引，建立Hash结构进行查找","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"数据库架构","slug":"数据库架构","permalink":"http://yoursite.com/tags/数据库架构/"}]},{"title":"HTTP与HTTPS的区别","slug":"HTTP与HTTPS的区别","date":"2019-10-08T06:08:59.000Z","updated":"2019-11-03T02:33:07.496Z","comments":true,"path":"2019/10/08/HTTP与HTTPS的区别/","link":"","permalink":"http://yoursite.com/2019/10/08/HTTP与HTTPS的区别/","excerpt":"","text":"HTTPS 简介 HTTP HTTPS HTTP HTTP SSL OR TLS TCP TCP IP IP HTTPS:以计算机网络通信安全为目的的传输协议 SSL(Security Sockets Layer,安全套接层) 为网络通信提供安全及数据完整性一种安全协议 是操作系统对外API ,SSL3.0 后更名为TLS 采用身份验证和数据加密保证网络通信安全和数据完整性HTTP数据传输流程 浏览器将支持的加密算法发送给服务器 服务器选择一套浏览器支持的加密算法，以证书形式回发给浏览器 浏览器验证证书合法性，结合证书公钥加密信息发送给服务器 服务器使用私钥解密，验证哈希加密响应消息回发浏览器 浏览器解密响应消息，对消息进行验真，之后进行加密交换数据 区别 HTTPS需要到CA申请证书，HTTP不需要 HTTP超文本传输协议明文传输，HTTPS密文传输，HTTPS基于具有安全性的SSL加密 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口 HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/计算机网络/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"HTTP相关","slug":"HTTP相关","date":"2019-10-06T08:59:45.000Z","updated":"2019-10-08T01:44:06.285Z","comments":true,"path":"2019/10/06/HTTP相关/","link":"","permalink":"http://yoursite.com/2019/10/06/HTTP相关/","excerpt":"","text":"超文本传输协议HTTP主要特点 支持客户/服务器模式 简单快速 灵活 无连接 无状态 请求/响应的步骤 客户端连接到web服务器 发送HTTP请求 服务器接受请求并返回HTTP响应 释放连接TCP连接 客户端浏览器解析HTML内容 在浏览器地址键入URL，按下回车之后经历的流程 DNS解析 浏览器依据URL逐层查询DNS服务器缓存，解析URL中的域名所对应的的IP TCP连接 找到IP地址后根据IP和对应端口和服务器建立TCP连接，结合三次握手讲解 浏览器发送HTTP请求 服务器处理请求并返回HTTP响应报文 浏览器解析渲染页面 连接结束 结合四次挥手HTTP状态码五种可能的取值 1XX : 指示信息 – 表示请求已接收，继续处理 2XX : 成功–表示请求已被成功接收、理解、接受 3XX : 重定向 – 要完成请求必须进行更进一步的操作 4xx : 客户端错误 – 请求有语法错误或请求无法实现 5XX : 服务器端错误–服务器未能实现合法的请求常见状态码 200 OK : 正常返回信息 400 Bad Request : 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized : 请求未经授权，这个状态码必须和WWW-Authenticate 报头域一起使用 403 Forbidden : 服务器收到请求，但是拒绝提供服务 404 Not Found : 请求资源不存在,eg,输入错误的URL 500 Internal Server Error : 服务器发生了不可预期的错误 503 Server Unavailable : 服务器当前不能处理客户端的请求，一段时间后可能恢复正常GET请求和POST请求的区别 Http报文层面：GET将信息放在URL，POST放在报文体中 数据库层面：GET符合幂等性和安全性，POST不符合 （幂等性：对数据库多次操作获得结果是一样的。安全性：没有改变数据库中的数据） 其他层面：GET可以被缓存、被储存，而POST不行 Cookie和Session的区别Cookie简介 由服务器发给客户端的特殊信息，以文本的形式存放在客户端 客户端再次请求的时候，会把Cookie回发 服务器接收到后，会解析Cookie生成与客户端相对应的内容 Cookie 的设置以及发送过程 客户端发送HTTP Request 到服务端 服务端发送HTTP Response + Set-Cookie 客户端发送HTTP Request + Cookie 服务器发送HTTP Response Session 简介 服务器端的机制，在服务器上保存的信息 解析客户端请求并操作session id,按需保存状态信息 Session的实现方式方式 使用Cookie来实现 服务器给每个session分配一个JSESSIONID,并通过Cookie发送给客户端，当客户端发起新的请求的时候，将在Cookie头中携带这个JSESSIONID，这样服务器能够找到客户端对应的session 使用URL回写来实现 URL回写指服务器在发送给浏览器页面的所有链接中都携带JSSESSIONID的参数，点击任何一个链接都会把JSESSIONID带回服务器。 Tomcat对session的实现一开始同时实现的，使用Cookie和URL回写机制，如果发现客户端支持cookie,就继续使用cookie停止使用URL回写，如果发现Cookie被禁用，就一直使用URL回写 Cookie和Session的区别 Cookie数据存放在客户的浏览器上，Session数据放在服务器上 Session相对Cookie更安全 若考虑减轻服务器负担，应当使用Cookie","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/计算机网络/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"TCP的滑动窗口","slug":"TCP的滑动窗口","date":"2019-10-06T08:59:45.000Z","updated":"2019-10-06T14:13:09.044Z","comments":true,"path":"2019/10/06/TCP的滑动窗口/","link":"","permalink":"http://yoursite.com/2019/10/06/TCP的滑动窗口/","excerpt":"","text":"RTT和RTO RTT:发送一个数据包到接受对应ACK所花费的时间 RTO:重传时间间隔；RTT是根据RTO计算出来的 我们要实现对数据的批量发送，TCP要解决可靠传输和包乱序的问题，所以TCP需要知道网络实际的数据处理带宽或是数据处理速度才不会引起网络拥塞导致丢包 TCP使用滑动窗口做流量控制与乱序重排 保证TCP可靠性 保证TCP的流控特性。（流量控制：window，用于接收方通知发送方自己还有多少缓冲区可以接受数据，发送方根据接收方的处理能力发送数据，不会导致接受不过来） TCP的传输可靠性来源于确认重传机制，TCP的滑动窗口可靠性也是建立在确认重传基础上。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/计算机网络/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://yoursite.com/tags/滑动窗口/"},{"name":"RTT","slug":"RTT","permalink":"http://yoursite.com/tags/RTT/"},{"name":"RTO","slug":"RTO","permalink":"http://yoursite.com/tags/RTO/"}]},{"title":"TCP和UDP的区别","slug":"TCP和UDP的区别","date":"2019-10-06T08:55:45.000Z","updated":"2019-10-06T09:02:12.625Z","comments":true,"path":"2019/10/06/TCP和UDP的区别/","link":"","permalink":"http://yoursite.com/2019/10/06/TCP和UDP的区别/","excerpt":"","text":"UDP简介 面向非连接 不维护连接状态，支持同时向多个客户端传输相同消息 数据包报头只有8个字节，额外开销较小 吞吐量只受限于数据生成速率，传输速率及机器性能 尽最大努力交付，不保证可靠交付，不需要维护复杂链接状态表 面向报文，不对应用程序提交的报文信息进行拆分或合并 TCP和UDP的区别 面向连接 VS 无连接 可靠性 有序性 速度 量级","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/计算机网络/"}],"tags":[{"name":"UDP","slug":"UDP","permalink":"http://yoursite.com/tags/UDP/"}]},{"title":"微信点餐系统-service层设计","slug":"微信点餐系统-service层设计","date":"2019-09-20T05:40:03.000Z","updated":"2019-11-04T12:04:39.026Z","comments":true,"path":"2019/09/20/微信点餐系统-service层设计/","link":"","permalink":"http://yoursite.com/2019/09/20/微信点餐系统-service层设计/","excerpt":"","text":"常用注解@Entity 表明该类为一个实体类,类名和表明要一致。@Table 当实体类映射的数据表名不同名时使用，与@Entity并列使用 @Table(name=”XXXXX”)。@DynamicUpdate 自动更新updateTime@Data 自动生成getter和setter方法以及构造方法@Transational 在测试方法中使用测试完自动回滚，数据不保存数据库 如何自动生成getter/setter,toString的方法、1.引入lombok依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; 2.安装lombok插件3.使用注解@Data 如何根据categoryType 查询返回List 对象方法命名规则： 123List&lt;ProductCategory&gt; findByCategoryTypeIn(List&lt;Integer&gt; list)List&lt;Integer&gt; list = Arrays.asList(1,2,3,4);repository.findByCategoryTypeIn(list); JAVA8特性把List里的属性封装进另一个List 1List&lt;Integer&gt; categoryTypeList = productInfoList.strem().map(e -&gt; e.getCategoryType()).collect(Collectors.toList()) VO ViewObject 返回给前端的对象1.应根据前端需要的字段重新定义一个 VO，不要有多余字段2.VO字段应该和对象的字段名称保持一致，方便Copy属性3.@JsonProperty 注解的使用， 123//返回给前台的JSON字段 转成自定义的名称@JsonProperty(&quot;id&quot;)private String productId 写代码中的注意事项1.不要在 for循环里有查询2.不要在代码里直接写数字，应该使用枚举","categories":[{"name":"Spring Boot 实战","slug":"Spring-Boot-实战","permalink":"http://yoursite.com/categories/Spring-Boot-实战/"}],"tags":[{"name":"lombok","slug":"lombok","permalink":"http://yoursite.com/tags/lombok/"}]},{"title":"微信点餐系统-日志框架","slug":"微信点餐系统-日志框架","date":"2019-09-18T06:22:17.000Z","updated":"2019-11-04T12:04:35.774Z","comments":true,"path":"2019/09/18/微信点餐系统-日志框架/","link":"","permalink":"http://yoursite.com/2019/09/18/微信点餐系统-日志框架/","excerpt":"","text":"使用的日志框架日志门面：SLF4J日志实现：Logback 使用slf4j 打印日志的两种方式1.手动初始化Log4j的一个实例 12Logger logger = LoggerFactory.getLogger(this.class)logger.info(&quot;info...&quot;); 2.使用注解 @Slf4j ,可以直接使用log添加依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 1log.info(&quot;info...&quot;); 使用占位符可直接打印变量123String name = &quot;root&quot;;String password = &quot;123455&quot;;log.info(&quot;name: &#123;&#125;, password: &#123;&#125;&quot; , name,password) Logback配置1.创建 logback-spring.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;configuration&gt; &lt;appender name=&quot;consoleLog&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;pattern&gt; %d - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=&quot;fileInfoLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;!--滚动策略,每天一个日志--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--路径--&gt; &lt;fileNamePattern&gt; F:\\log\\tomcat\\info.%d.log &lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;appender name=&quot;fileErrorLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;!--滚动策略--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--路径--&gt; &lt;fileNamePattern&gt; F:\\log\\tomcat\\error.%d.log &lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;consoleLog&quot;/&gt; &lt;appender-ref ref=&quot;fileInfoLog&quot;/&gt; &lt;appender-ref ref=&quot;fileErrorLog&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt;","categories":[{"name":"Spring Boot 实战","slug":"Spring-Boot-实战","permalink":"http://yoursite.com/categories/Spring-Boot-实战/"}],"tags":[{"name":"日志框架","slug":"日志框架","permalink":"http://yoursite.com/tags/日志框架/"}]},{"title":"微信点餐系统-数据库设计","slug":"微信点餐系统-数据库设计","date":"2019-09-18T01:36:50.000Z","updated":"2019-11-04T12:04:24.970Z","comments":true,"path":"2019/09/18/微信点餐系统-数据库设计/","link":"","permalink":"http://yoursite.com/2019/09/18/微信点餐系统-数据库设计/","excerpt":"","text":"数据库设计表的的构成类目表，商品表，订单主表，订单详情表 日期时间类型设置默认时间，DEFAULT CURRENT_TIMESTAMP时间类型字段自动更新数据，ON UPDATE CURRENT_TIMESTAMP SQL UNIQUE 约束UNIQUE约束唯一标识数据库表中的每条记录。UNIQUE和PRIMARY KEY 约束均为列或列激活提供了唯一性的保证。PRIMARY KEY 拥有自动定义的 UNIQUE约束。请注意，每个表可以有多个UNIQUE约束，但是每个表只能有一个 PRIMARY KEY 约束。 数据库编码使用 UTF-8 unicode(uftf8mb4)可以存表情","categories":[{"name":"Spring Boot 实战","slug":"Spring-Boot-实战","permalink":"http://yoursite.com/categories/Spring-Boot-实战/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"TCP的三次握手和四次挥手","slug":"TCP的三次握手和四次挥手","date":"2019-05-22T07:51:17.000Z","updated":"2019-11-02T04:04:22.740Z","comments":true,"path":"2019/05/22/TCP的三次握手和四次挥手/","link":"","permalink":"http://yoursite.com/2019/05/22/TCP的三次握手和四次挥手/","excerpt":"","text":"TCP的三次握手TCP报文头source port （源端口）destination（目标端口）Sequence Number（同步序号）Acknowledgement Number（确认序号）Offset（偏移量）Reserved（保留域）TCP Flags（标志位）Window（滑动窗口）CheckSum（检验和）Urgent Pointer（紧急指针）TCP Options（定义一些可选参数） TCP报文头包含源端口及目的端口，IP地址可以唯一标识主机，TCP协议加端口可以唯一标识主机中的一个进程。可以使用IP+协议+端口来唯一标识网络中的一个进程。在一些场景下也把这种模式称为“套接字”即Socket。 TCP FlagsURG: 紧急指针是否有效ACK: 表示确认标志，携带 ack 标志的报文也称为确认报文PSH: 提示接收端收到报文之后应该立即将数据推送给应用程 序，而不是放在缓冲区排队RET: 表示要求对方重新简历连接。SYN: 同步序列号，用于建立连接过程FIN: 传输结束标志，告知对方自己即将关闭连接。 TCP三次握手流程（“握手是为了建立连接”） 在TPC/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接 第一次握手： 建立连接时，客户端发送SYN包（seq=x）到服务器，并进入SYN_SENT状态，等待服务器确认 第二次握手：服务器收到SYN包，必须确认客户的SYN(ack=x+1),同时自己也发送一个SYN包（sql=y）,即SYN+ACK包，此时服务器进入SYN_RECV状态 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1) ,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手各个状态的意义如下： LISTEN - 侦听来自远方TCP端口的连接请求； SYN-SENT -在发送连接请求后等待匹配的连接请求； SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； 为什么需要三次握手才能建立连接为了初始化Sequence Number的初始值 首次握手隐患——SYN超时 Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认 Server不断重试直至超时，Linux默认5次，总共需要63秒断开连接。针对SYN Flood的防护措施客户端给服务器发送一个SYN报文，下线，服务器需要默认等63秒才会断开。通过这个方法可以耗尽服务器的SYN连接队列。 SYN队列满后，通过tcp_syncookies参数回发SYN Cookie 若为正常连接则Client会回发SYN Cookie，直接建立连接建立连接后，Client出现故障怎么办保活机制：建立TCP连接后，TCP有保活机制，以应对其中一端出现故障。若连接处于非活动状态，则开启保活功能的一方将向另一方发送保活探测报文，达到keepalive time时间间隔仍未收到响应则重试，若尝试次数达到保活探测数仍未收到对方的响应，则连接断开。 TCP的四次挥手TCP四次挥手流程（挥手是为了终止连接）第一次挥手： Client发送一个FIN,用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态； 第二次挥手： Server收到FIN后，发送ACK给Client,确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态； 第三次握手： Serveer发送一个FIN,用来关闭Server到Client的数据传送，Server进入LAST_ACK状态； 第四次挥手： Clien收到FIN后，Client进入TIME_WAIT状态，急着发送一个ACK给Server,确认序号为收到的序号+1，Server进入CLOSED状态，完成四次挥手； TCP连接必须经过时间2MSL后才真正释放掉？ 保证有足够时间让对方收到ACK包 避免新旧连接混淆 为什么四次挥手才能断开连接因为TCP是全双工的，发送方和接收方都需要FIN报文和ACK报文 服务器出现大量CLOSE_WAIT状态的原因对方关闭socket连接，我方忙于读或写，没有及时关闭 检查代码，特别是释放资源的代码 检查配置，特别是处理请求的线程配置 netstat查看机器网络状态的指令12查看服务器处于各个状态下的连接数 netstat -n | awk &apos;/^tcp/&#123;++S[$NF]&#125;END(FOR(a in S) print a,S[a])&apos;","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/计算机网络/"}],"tags":[{"name":"TCP的三次握手","slug":"TCP的三次握手","permalink":"http://yoursite.com/tags/TCP的三次握手/"},{"name":"TCP的四次挥手","slug":"TCP的四次挥手","permalink":"http://yoursite.com/tags/TCP的四次挥手/"}]},{"title":"网络基础知识","slug":"网络基础知识讲解","date":"2019-04-25T10:40:12.000Z","updated":"2019-10-11T04:09:00.540Z","comments":true,"path":"2019/04/25/网络基础知识讲解/","link":"","permalink":"http://yoursite.com/2019/04/25/网络基础知识讲解/","excerpt":"","text":"OSI开放式互联参考模型 物理层： 定义物理设备标准（网线类型、光纤接口类型、各种传输介质的传输速率）,主要作用：传输比特流0101二进制数据 —&gt; 转化为电流强弱 —&gt; 0101 数模转换和模数转换 单位:比特 （网卡） 数据链路层： 定义了如何格式化数据以进行传输，和控制对物理介质的访问。主要作用：提供错误检测和纠正，确保数据传输可靠性。该层将比特数据组成为帧。（交换机） 网络层： 将网络地址翻译成对应的物理地址，决定数据从发送方路由到接收方，单位是数据包。有IP协议）路由器 传输层： 解决主机间的数据传输。（传输协议，流量控制，接收方接收数据快慢程度，规定发送速率；还可以分割大的数据包；TCP和UDP协议） 会话层： 定义不同机器上的用户之间建立及管理回话，解决应用程序之间的通信，自动收发包和寻址的功能 表示层： 解决不同操作系统之间的通信语法问题。信息的语法语义，加密解密，转换翻译 应用层： 规定接收方发送方必须使用一个固定长度的消息头，消息头必须使用固定的组成继续消息体的长度，关注TCP/IP协议中的http协议 OSI 参考模型并不是一个标准，概念性框架。事实的标准是 TCP/IP 四层架构参考模型 OSI的“实现” TCP/IP协议 TCP/IP四层模型（从下到上）：链路层：获取以太网首部网络层：获取IP首部传输层：获取TCP首部应用层：HTTP数据","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/计算机网络/"}],"tags":[{"name":"OSI七层模型","slug":"OSI七层模型","permalink":"http://yoursite.com/tags/OSI七层模型/"}]}]}